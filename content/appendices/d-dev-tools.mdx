---
title: Development Tools
description: Frameworks, libraries, and utilities for EVM development
---

# Appendix D: Development Tools

This appendix covers the essential tools for EVM smart contract development in 2026.

## Frameworks

Frameworks automate tedious tasks and make development easier. In 2026, the two dominant frameworks for EVM development are **Hardhat** (JavaScript/TypeScript) and **Foundry** (Solidity-native). Both work identically on Ethereum Classic and Ethereum—they connect to any EVM chain via RPC.

### Hardhat

- **GitHub**: [github.com/NomicFoundation/hardhat](https://github.com/NomicFoundation/hardhat)
- **Website**: [hardhat.org](https://hardhat.org)
- **Documentation**: [hardhat.org/docs](https://hardhat.org/docs)

Hardhat is the most widely used Ethereum development framework for JavaScript and TypeScript developers. It provides a flexible, extensible environment for compiling, deploying, testing, and debugging smart contracts.

**Key features:**

- **Hardhat Network**: Built-in local blockchain with advanced debugging (console.log in Solidity, stack traces, mainnet forking)
- **TypeScript support**: First-class TypeScript integration with type generation
- **Plugin ecosystem**: Rich ecosystem of plugins for testing, deployment, verification
- **Multi-network**: Easy configuration for ETC, ETH, and testnets

#### Installing Hardhat

Hardhat requires Node.js v18+ and npm. Install using nvm:

```bash
nvm install --lts
node -v  # v20.11.0
npm -v   # 10.2.4
```

Create a project:

```bash
mkdir Faucet
cd Faucet
npm init -y
npm install --save-dev hardhat
npx hardhat init
```

Select "Create a TypeScript project" for the best experience. The project structure:

```
Faucet
├── contracts/
│   └── Lock.sol
├── ignition/
│   └── modules/
├── test/
│   └── Lock.ts
├── hardhat.config.ts
├── package.json
└── tsconfig.json
```

Install additional dependencies:

```bash
npm install --save-dev @nomicfoundation/hardhat-toolbox
npm install @openzeppelin/contracts
```

#### Configuring for ETC and ETH

Edit `hardhat.config.ts`:

```typescript
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import * as dotenv from "dotenv";

dotenv.config();

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.24",
    settings: {
      optimizer: { enabled: true, runs: 200 },
      evmVersion: "shanghai",
    },
  },
  networks: {
    // ETC Networks
    mordor: {
      url: process.env.MORDOR_RPC || "https://rpc.mordor.etccooperative.org",
      chainId: 63,
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
    },
    etc: {
      url: process.env.ETC_RPC || "https://etc.rivet.link",
      chainId: 61,
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
    },
    // ETH Networks
    sepolia: {
      url: process.env.SEPOLIA_RPC || "https://rpc.sepolia.org",
      chainId: 11155111,
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
    },
    mainnet: {
      url: process.env.ETH_RPC || "https://eth.llamarpc.com",
      chainId: 1,
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
    },
  },
};

export default config;
```

Create a `.env` file (add to `.gitignore`!):

```
PRIVATE_KEY=your_private_key_here
```

#### Deploying with Hardhat Ignition

Hardhat uses **Ignition** for deployments—a declarative system that tracks deployments and handles dependencies automatically.

Create `ignition/modules/Faucet.ts`:

```typescript
import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

const FaucetModule = buildModule("FaucetModule", (m) => {
  const faucet = m.contract("Faucet");
  return { faucet };
});

export default FaucetModule;
```

Deploy:

```bash
npx hardhat compile
npx hardhat ignition deploy ignition/modules/Faucet.ts --network mordor
```

#### Using the Hardhat Console

```bash
npx hardhat console --network mordor
```

```javascript
> const [signer] = await ethers.getSigners()
> const balance = await ethers.provider.getBalance(signer.address)
> ethers.formatEther(balance)
'3.2'

> const Faucet = await ethers.getContractFactory("Faucet")
> const faucet = Faucet.attach("0x1234...5678")
> await faucet.withdraw(ethers.parseEther("0.1"))
```

### Foundry

- **GitHub**: [github.com/foundry-rs/foundry](https://github.com/foundry-rs/foundry)
- **Documentation**: [book.getfoundry.sh](https://book.getfoundry.sh)

Foundry is a blazing-fast toolkit written in Rust, particularly popular for:

- **Solidity-native testing**: Write tests in Solidity, not JavaScript
- **Speed**: Extremely fast compilation and test execution
- **Fuzzing**: Built-in property-based testing
- **Mainnet forking**: Test against real mainnet state
- **Gas reporting**: Detailed gas usage analysis

Foundry consists of:

- **Forge**: Testing framework
- **Cast**: Command-line tool for interacting with contracts
- **Anvil**: Local testnet node
- **Chisel**: Solidity REPL

#### Installing Foundry

```bash
curl -L https://foundry.paradigm.xyz | bash
foundryup
forge --version
```

#### Creating a Foundry Project

```bash
forge init Faucet
cd Faucet
```

Structure:

```
Faucet
├── src/
│   └── Counter.sol
├── test/
│   └── Counter.t.sol
├── script/
├── foundry.toml
└── lib/
```

#### Configuring for ETC

Edit `foundry.toml`:

```toml
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc = "0.8.24"
evm_version = "shanghai"
optimizer = true
optimizer_runs = 200

[rpc_endpoints]
mordor = "https://rpc.mordor.etccooperative.org"
etc = "https://etc.rivet.link"
sepolia = "https://rpc.sepolia.org"
mainnet = "https://eth.llamarpc.com"
```

#### Writing Solidity Tests

```solidity
// test/Faucet.t.sol
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/Faucet.sol";

contract FaucetTest is Test {
    Faucet public faucet;
    address public user;

    function setUp() public {
        faucet = new Faucet();
        user = makeAddr("user");
        vm.deal(address(faucet), 1 ether);
    }

    function test_Withdraw() public {
        vm.prank(user);
        faucet.withdraw(0.1 ether);
        assertEq(user.balance, 0.1 ether);
    }

    function testFuzz_Withdraw(uint256 amount) public {
        amount = bound(amount, 1, 0.1 ether);
        vm.prank(user);
        faucet.withdraw(amount);
        assertEq(user.balance, amount);
    }
}
```

Run tests:

```bash
forge test
```

#### Deploying with Foundry

Create `script/Deploy.s.sol`:

```solidity
pragma solidity ^0.8.24;

import "forge-std/Script.sol";
import "../src/Faucet.sol";

contract DeployScript is Script {
    function run() public {
        vm.startBroadcast();
        new Faucet();
        vm.stopBroadcast();
    }
}
```

Deploy:

```bash
forge script script/Deploy.s.sol --rpc-url mordor --broadcast --private-key $PRIVATE_KEY
```

### OpenZeppelin Contracts

- **GitHub**: [github.com/OpenZeppelin/openzeppelin-contracts](https://github.com/OpenZeppelin/openzeppelin-contracts)
- **Documentation**: [docs.openzeppelin.com/contracts](https://docs.openzeppelin.com/contracts)

The most widely used library of secure, audited smart contracts. Version 5.x supports Solidity ^0.8.20.

**Key contracts:**

- **ERC20, ERC721, ERC1155**: Token standard implementations
- **AccessControl, Ownable**: Role-based and simple access control
- **ReentrancyGuard**: Protection against reentrancy attacks
- **Pausable**: Emergency stop functionality
- **SafeERC20**: Safe token transfer wrappers

#### Installing

With Hardhat:
```bash
npm install @openzeppelin/contracts
```

With Foundry:
```bash
forge install OpenZeppelin/openzeppelin-contracts
```

Add to `remappings.txt`:
```
@openzeppelin/=lib/openzeppelin-contracts/
```

#### Example: ERC20 Token

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract MyToken is ERC20, Ownable {
    constructor() ERC20("MyToken", "MTK") Ownable(msg.sender) {
        _mint(msg.sender, 1000000 * 10 ** decimals());
    }

    function mint(address to, uint256 amount) public onlyOwner {
        _mint(to, amount);
    }
}
```

## Libraries

### ethers.js

The most widely used Ethereum library in 2026, known for its clean API and TypeScript support. Default library for Hardhat.

- **GitHub**: [github.com/ethers-io/ethers.js](https://github.com/ethers-io/ethers.js)
- **Documentation**: [docs.ethers.org](https://docs.ethers.org)

```typescript
import { ethers } from "ethers";

// Connect to Mordor testnet
const provider = new ethers.JsonRpcProvider(
  "https://rpc.mordor.etccooperative.org"
);

// Get balance
const balance = await provider.getBalance("0x...");
console.log(ethers.formatEther(balance), "METC");

// Connect wallet
const wallet = new ethers.Wallet(privateKey, provider);

// Interact with contract
const faucet = new ethers.Contract(address, abi, wallet);
await faucet.withdraw(ethers.parseEther("0.1"));
```

### viem

A modern TypeScript-first alternative to ethers.js, designed for smaller bundle sizes. Used by wagmi and RainbowKit.

- **GitHub**: [github.com/wevm/viem](https://github.com/wevm/viem)
- **Documentation**: [viem.sh](https://viem.sh)

```typescript
import { createPublicClient, http } from "viem";

// Define ETC Mordor chain
const mordor = {
  id: 63,
  name: "Mordor",
  network: "mordor",
  nativeCurrency: { name: "Mordor Ether", symbol: "METC", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.mordor.etccooperative.org"] },
  },
};

const client = createPublicClient({
  chain: mordor,
  transport: http(),
});

const balance = await client.getBalance({ address: "0x..." });
```

### Other Libraries

| Library | Language | Documentation |
|---------|----------|---------------|
| web3.js | JavaScript | [docs.web3js.org](https://docs.web3js.org) |
| web3.py | Python | [web3py.readthedocs.io](https://web3py.readthedocs.io) |
| web3j | Java/Kotlin | [docs.web3j.io](https://docs.web3j.io) |
| Nethereum | .NET | [docs.nethereum.com](https://docs.nethereum.com) |

## Testing Smart Contracts

### Test Frameworks Summary

| Framework | Test Language | Testing Framework | Local Blockchain |
|-----------|--------------|-------------------|------------------|
| Hardhat | TypeScript/JavaScript | Mocha + Chai | Hardhat Network |
| Foundry | Solidity | forge-std | Anvil |

### Hardhat Testing

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";

describe("Faucet", function () {
  it("Should allow withdrawal", async function () {
    const Faucet = await ethers.getContractFactory("Faucet");
    const faucet = await Faucet.deploy();

    const [owner] = await ethers.getSigners();
    await owner.sendTransaction({
      to: faucet.target,
      value: ethers.parseEther("1.0")
    });

    await expect(
      faucet.withdraw(ethers.parseEther("0.1"))
    ).to.changeEtherBalance(owner, ethers.parseEther("0.1"));
  });
});
```

Run: `npx hardhat test`

### Foundry Testing

```solidity
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "../src/Faucet.sol";

contract FaucetTest is Test {
    Faucet faucet;

    function setUp() public {
        faucet = new Faucet();
        vm.deal(address(faucet), 1 ether);
    }

    function test_Withdraw() public {
        address user = makeAddr("user");
        vm.prank(user);
        faucet.withdraw(0.1 ether);
        assertEq(user.balance, 0.1 ether);
    }
}
```

Run: `forge test`

### Local Test Blockchains

**Hardhat Network:**
```bash
npx hardhat test      # Auto-starts for tests
npx hardhat node      # Standalone mode
```

Features: Solidity stack traces, console.log, mainnet forking, time manipulation.

**Anvil:**
```bash
anvil
anvil --chain-id 63  # Mordor chain ID
```

Features: Fast execution, mainnet forking, state snapshots, address impersonation.

### When to Use Mordor vs Local

| Scenario | Recommended |
|----------|-------------|
| Unit tests | Hardhat Network or Anvil |
| Integration tests | Local (with forking if needed) |
| Pre-deployment verification | Mordor testnet |
| Testing PoW mechanics | Mordor testnet |
| CI/CD pipelines | Hardhat Network or Anvil |

## Command-Line Utilities

### Cast (Foundry)

```bash
# Get transaction receipt
cast receipt <txhash> --rpc-url mordor

# Get contract code
cast code <address> --rpc-url mordor

# Read storage slot
cast storage <address> <slot> --rpc-url mordor

# Call a view function
cast call <address> "getBalance()" --rpc-url mordor

# Send a transaction
cast send <address> "withdraw(uint256)" 100000000000000000 --rpc-url mordor --private-key $KEY
```

### helpeth (EthereumJS)

```bash
helpeth keyGenerate           # Generate new key
helpeth keyDetails            # Print key details
helpeth parseTx <tx>          # Parse raw transaction
helpeth unitConvert 1 ether wei  # Convert units
```

## Agentic Development Tools

AI-assisted development is transforming EVM development. These tools enable small teams to achieve what previously required large engineering organizations.

### Claude Code

Claude Code is Anthropic's official CLI for AI-assisted development. It integrates directly with your development workflow.

- **Documentation**: [docs.anthropic.com/claude-code](https://docs.anthropic.com/en/docs/claude-code)
- **Installation**: `npm install -g @anthropic-ai/claude-code`

**Key features for EVM development:**

- Direct integration with Foundry and Hardhat
- Contract generation, review, and testing
- On-chain data access via MCP servers
- Project-specific configuration via CLAUDE.md

#### Setting Up for EVM Projects

Create a `CLAUDE.md` file in your project root:

```markdown
# CLAUDE.md - EVM Development

You are developing smart contracts for Ethereum Classic and Ethereum.

## Project Context
- Framework: Foundry (or Hardhat)
- Networks: Mordor (ETC testnet), Sepolia (ETH testnet)
- Solidity version: 0.8.24

## Development Principles
- Prioritize security over convenience
- Test thoroughly before deployment
- Document all external interactions
- Consider gas optimization for production

## Network Details
- ETC Mainnet: chainId 61, https://etc.rivet.link
- Mordor Testnet: chainId 63, https://rpc.mordor.etccooperative.org
```

#### MCP Servers for On-Chain Data

The Model Context Protocol (MCP) connects Claude to external data sources. Configure in `.claude/settings.json`:

```json
{
  "mcpServers": {
    "ethereum": {
      "command": "npx",
      "args": ["-y", "@anthropic/mcp-ethereum"],
      "env": {
        "RPC_URL": "https://rpc.mordor.etccooperative.org"
      }
    }
  }
}
```

With MCP enabled, Claude can:
- Query on-chain state and balances
- Fetch and analyze deployed contract code
- Check transaction receipts and logs
- Verify contract deployments

### GitHub Copilot

GitHub Copilot provides AI-powered code completion directly in your IDE. It excels at autocompleting Solidity patterns, test scaffolding, and repetitive code.

- **Website**: [github.com/features/copilot](https://github.com/features/copilot)
- **Documentation**: [docs.github.com/copilot](https://docs.github.com/en/copilot)

**Key features for EVM development:**

- Inline code completion for Solidity and TypeScript
- Pattern recognition from OpenZeppelin and common contracts
- Test generation assistance
- NatSpec documentation completion

#### Installing Copilot

**VS Code:**
1. Install the "GitHub Copilot" extension from the marketplace
2. Sign in with your GitHub account (requires Copilot subscription)
3. Copilot activates automatically in supported files (.sol, .ts, .js)

**Neovim:**
```bash
# Using lazy.nvim
{
  "github/copilot.vim",
  config = function()
    vim.g.copilot_filetypes = { solidity = true }
  end,
}
```

Run `:Copilot setup` and authenticate with GitHub.

**JetBrains IDEs:**
1. Install "GitHub Copilot" from Preferences → Plugins
2. Restart the IDE and sign in via Tools → GitHub Copilot → Login

#### Configuring for Solidity

Create `.github/copilot-instructions.md` in your project root:

```markdown
# Copilot Instructions for EVM Development

When generating Solidity code:
- Target Solidity ^0.8.24
- Use OpenZeppelin contracts v5.x patterns
- Include NatSpec documentation (@notice, @param, @return)
- Follow checks-effects-interactions pattern
- Emit events for state changes

When generating tests:
- Use Foundry's forge-std for Solidity tests
- Use Hardhat with ethers.js v6 for TypeScript tests
- Include edge cases and failure scenarios
```

#### Effective Prompts for Solidity

Write descriptive comments to guide Copilot:

```solidity
// ERC-20 token with 1 million fixed supply, minted to deployer
contract MyToken is ERC20 {
    // Copilot will complete the constructor
}

// Withdraw function with reentrancy protection
// Requires balance >= amount, emits Withdrawal event
function withdraw(uint256 amount) external {
    // Copilot will implement the pattern
}
```

#### Copilot Chat

Copilot Chat provides conversational assistance within your IDE:

- **VS Code**: Open via Ctrl/Cmd+Shift+I or the chat icon
- **JetBrains**: Tools → GitHub Copilot → Chat

Example queries:
- "Explain this contract's access control"
- "Add fuzz tests for the withdraw function"
- "What vulnerabilities should I check for?"

### Cursor

Cursor is a fork of VS Code with deep AI integration, designed for AI-first development. It combines familiar VS Code functionality with powerful AI features.

- **Website**: [cursor.com](https://cursor.com)
- **Documentation**: [docs.cursor.com](https://docs.cursor.com)

**Key features for EVM development:**

- **Composer**: Multi-file editing with AI across your codebase
- **Chat**: Context-aware conversations about your code
- **Cmd+K**: Inline code generation and editing
- **Codebase indexing**: AI understands your entire project structure
- **Multiple models**: Choose between Claude, GPT-4, and others

#### Installing Cursor

Download from [cursor.com](https://cursor.com) for macOS, Windows, or Linux. Cursor imports your VS Code settings, extensions, and keybindings automatically.

#### Configuring for Solidity

1. Install the Solidity extension (Juan Blanco or Nomic Foundation)
2. Open Settings (Cmd/Ctrl+,) → Cursor Settings
3. Enable "Include project context" for better completions

Create `.cursorrules` in your project root:

```
You are an expert Solidity developer working on EVM smart contracts.

Project context:
- Solidity version: ^0.8.24
- Framework: Foundry
- Networks: Ethereum Classic (chainId 61), Ethereum (chainId 1)

Code standards:
- Use OpenZeppelin contracts v5.x
- Follow checks-effects-interactions pattern
- Include NatSpec documentation for all public functions
- Emit events for all state changes
- Use custom errors instead of require strings

Security priorities:
- Check for reentrancy vulnerabilities
- Validate all external inputs
- Consider gas optimization for loops
- Document trust assumptions
```

#### Using Composer for Multi-File Edits

Press Cmd/Ctrl+Shift+I to open Composer. Describe changes that span multiple files:

```
Add a withdrawal limit feature to the Faucet contract:
1. Add a daily limit of 1 ETH per address in Faucet.sol
2. Create a mapping to track withdrawals per day
3. Update the tests in Faucet.t.sol to cover the new limit
4. Add the limit as a constructor parameter
```

Composer will propose edits across all relevant files for review before applying.

#### Inline Editing with Cmd+K

Select code and press Cmd/Ctrl+K for targeted edits:

- "Add reentrancy guard to this function"
- "Convert to use custom errors"
- "Add NatSpec documentation"
- "Optimize gas usage"

### ChatGPT

OpenAI's ChatGPT provides conversational AI assistance for EVM development through web and API interfaces.

- **Website**: [chat.openai.com](https://chat.openai.com)
- **API Documentation**: [platform.openai.com/docs](https://platform.openai.com/docs)

**Key features for EVM development:**

- Code generation and explanation
- Security review assistance
- Documentation writing
- Learning and research

#### Using ChatGPT for Solidity

ChatGPT works best with clear context. Start conversations with project details:

```
I'm developing smart contracts for Ethereum Classic using:
- Solidity ^0.8.24
- Foundry for testing
- OpenZeppelin contracts v5.x

Help me implement a token vesting contract with:
- Linear vesting over 12 months
- Cliff period of 3 months
- Revocable by admin
```

#### Custom GPTs for EVM Development

Create a Custom GPT with specialized instructions:

1. Go to chat.openai.com → Explore GPTs → Create
2. Add system instructions:

```
You are an expert EVM smart contract developer.

When writing Solidity:
- Target version ^0.8.24
- Use OpenZeppelin v5.x patterns
- Include comprehensive NatSpec
- Follow security best practices

When reviewing code:
- Check for common vulnerabilities (reentrancy, overflow, access control)
- Identify centralization risks
- Suggest gas optimizations

Always explain your reasoning and trade-offs.
```

3. Add knowledge files (OpenZeppelin docs, your style guide)

#### ChatGPT Code Interpreter

For data analysis tasks, use Code Interpreter:

- Analyze gas usage patterns from transaction data
- Parse and visualize on-chain data exports
- Generate charts for token distribution analysis
- Process large CSV files of blockchain data

Upload your data file and describe the analysis:

```
This CSV contains all transactions to my contract over 30 days.
Analyze:
1. Gas usage distribution
2. Peak usage times
3. Most common function calls
4. Unique user counts per day
```

#### API Integration

Integrate GPT models into development workflows:

```typescript
import OpenAI from "openai";

const openai = new OpenAI();

async function reviewContract(source: string): Promise<string> {
  const response = await openai.chat.completions.create({
    model: "gpt-4-turbo",
    messages: [
      {
        role: "system",
        content: "You are a smart contract security auditor. Review the code for vulnerabilities.",
      },
      {
        role: "user",
        content: `Review this Solidity contract:\n\n${source}`,
      },
    ],
  });
  return response.choices[0].message.content;
}
```

### Agentic Workflows

Effective patterns for AI-assisted EVM development:

**Contract Generation:**
```
Generate an ERC-20 token with fixed supply, no admin functions,
and full NatSpec documentation. Include Foundry tests.
```

**Security Review:**
```
Review this contract for reentrancy, access control issues,
and centralization risks. Check against common vulnerability patterns.
```

**Test Generation:**
```
Generate comprehensive Foundry tests including:
- Unit tests for each function
- Fuzz tests for input validation
- Invariant tests for critical properties
```

**Deployment Verification:**
```
Verify the deployed contract at <address> on Mordor matches
the source code. Check constructor arguments and initialization.
```

### Best Practices

1. **Encode project principles** in CLAUDE.md for consistent output
2. **Review generated code** before deployment—agents can hallucinate
3. **Test on Mordor/Sepolia** before mainnet deployment
4. **Use agents for routine tasks**, humans for architecture decisions
5. **Combine AI review with human review** for production code

See Chapter 18: Agentic Development for comprehensive coverage of AI-assisted blockchain development.

## Resources

- **Hardhat**: [hardhat.org](https://hardhat.org)
- **Foundry Book**: [book.getfoundry.sh](https://book.getfoundry.sh)
- **OpenZeppelin**: [docs.openzeppelin.com](https://docs.openzeppelin.com)
- **ethers.js**: [docs.ethers.org](https://docs.ethers.org)
- **viem**: [viem.sh](https://viem.sh)
- **Claude Code**: [docs.anthropic.com/claude-code](https://docs.anthropic.com/en/docs/claude-code)
- **Cursor**: [cursor.com](https://cursor.com)
- **GitHub Copilot**: [github.com/features/copilot](https://github.com/features/copilot)
- **ChatGPT**: [chat.openai.com](https://chat.openai.com)
