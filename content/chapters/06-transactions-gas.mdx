---
title: Transactions & Gas
description: Transaction types, EIP-1559, gas estimation, and mempool dynamics
chapter: 6
---

# Transactions

Transactions are signed messages originated by an externally owned account, transmitted by the network, and recorded on the blockchain. This basic definition conceals important details worth understanding. Transactions are the only mechanism that can trigger a state change or cause a contract to execute in the EVM. Ethereum is a global singleton state machine, and transactions are what make that state machine "tick," changing its state. Contracts don't run on their own. Ethereum doesn't run autonomously. Everything starts with a transaction.

In this chapter, we will dissect transactions, show how they work, and examine the details. Note that much of this chapter is addressed to those who are interested in managing their own transactions at a low level, perhaps because they are writing a wallet app; you don't have to worry about this if you are happy using existing wallet applications, although you may find the details interesting!

## The Structure of a Transaction

First let's take a look at the basic structure of a transaction, as it is serialized and transmitted on the Ethereum network. Each client and application that receives a serialized transaction will store it in-memory using its own internal data structure, perhaps embellished with metadata that doesn't exist in the network serialized transaction itself. The network-serialization is the only standard form of a transaction.

<Callout type="info">
This section describes **legacy (Type 0) transactions**. Modern EVM networks support multiple transaction types with different fields—see the "Transaction Types" section for details on Type 1 (access lists), Type 2 (EIP-1559), and Type 3 (blobs).
</Callout>

A legacy transaction is a serialized binary message that contains the following data:

**Nonce** — A sequence number, issued by the originating EOA, used to prevent message replay

**Gas price** — The price of gas (in wei) the originator is willing to pay

**Gas limit** — The maximum amount of gas the originator is willing to buy for this transaction

**Recipient** — The destination Ethereum address

**Value** — The amount of ether to send to the destination

**Data** — The variable-length binary data payload

**v, r, s** — The three components of an ECDSA digital signature of the originating EOA

The transaction message's structure is serialized using the Recursive Length Prefix (RLP) encoding scheme, which was created specifically for simple, byte-perfect data serialization in Ethereum. All numbers in Ethereum are encoded as big-endian integers, of lengths that are multiples of 8 bits.

Note that the field labels (to, gas limit, etc.) are shown here for clarity, but are not part of the transaction serialized data, which contains the field values RLP-encoded. In general, RLP does not contain any field delimiters or labels. RLP's length prefix is used to identify the length of each field. Anything beyond the defined length belongs to the next field in the structure.

For example, you may notice there is no "from" data in the address identifying the originator EOA. That is because the EOA's public key can be derived from the v, r, s components of the ECDSA signature. The address can, in turn, be derived from the public key. When you see a transaction showing a "from" field, that was added by the software used to visualize the transaction.

## The Transaction Nonce

The nonce is one of the most important and least understood components of a transaction. The definition in the Yellow Paper reads:

> nonce: A scalar value equal to the number of transactions sent from this address or, in the case of accounts with associated code, the number of contract-creations made by this account.

Strictly speaking, the nonce is an attribute of the originating address; that is, it only has meaning in the context of the sending address. However, the nonce is not stored explicitly as part of an account's state on the blockchain. Instead, it is calculated dynamically, by counting the number of confirmed transactions that have originated from an address.

There are two scenarios where the existence of a transaction-counting nonce is important: the usability feature of transactions being included in the order of creation, and the vital feature of transaction duplication protection. Let's look at an example scenario for each of these:

1. Imagine you wish to make two transactions. You have an important payment to make of 6 ether, and also another payment of 8 ether. You sign and broadcast the 6-ether transaction first, because it is the more important one, and then you sign and broadcast the second, 8-ether transaction. Sadly, you have overlooked the fact that your account contains only 10 ether, so the network can't accept both transactions: one of them will fail. Because you sent the more important 6-ether one first, you understandably expect that one to go through and the 8-ether one to be rejected. However, in a decentralized system like Ethereum, nodes may receive the transactions in either order; there is no guarantee that a particular node will have one transaction propagated to it before the other. Without the nonce, it would be random as to which one gets accepted and which rejected. However, with the nonce included, the first transaction you sent will have a nonce of, let's say, 3, while the 8-ether transaction has the next nonce value (i.e., 4). So, that transaction will be ignored until the transactions with nonces from 0 to 3 have been processed, even if it is received first.

2. Now imagine you have an account with 100 ether. You find someone online who will accept payment in ether for a widget that you really want to buy. You send them 2 ether and they send you the widget. To make that 2-ether payment, you signed a transaction sending 2 ether from your account to their account, and then broadcast it to the Ethereum network to be verified and included on the blockchain. Now, without a nonce value in the transaction, a second transaction sending 2 ether to the same address a second time will look exactly the same as the first transaction. This means that anyone who sees your transaction on the Ethereum network can "replay" the transaction again and again until all your ether is gone simply by copying and pasting your original transaction and resending it to the network. However, with the nonce value included in the transaction data, *every single transaction is unique*, even when sending the same amount of ether to the same recipient address multiple times. Thus, by having the incrementing nonce as part of the transaction, it is simply not possible for anyone to "duplicate" a payment you have made.

### Keeping Track of Nonces

In practical terms, the nonce is an up-to-date count of the number of *confirmed* (i.e., on-chain) transactions that have originated from an account. To find out what the nonce is, you can query the blockchain using ethers.js. In the Hardhat console connected to a testnet:

```javascript
$ npx hardhat console --network mordor
> await ethers.provider.getTransactionCount("0x9e713963a92c02317a681b9bb3065a8249de124f")
40
```

<Tip>
The nonce is a zero-based counter, meaning the first transaction has nonce 0. In this example, we have a transaction count of 40, meaning nonces 0 through 39 have been seen. The next transaction's nonce will need to be 40.
</Tip>

Your wallet will keep track of nonces for each address it manages. It's fairly simple to do that, as long as you are only originating transactions from a single point.

<Warning>
Be careful when using the `getTransactionCount` function for counting pending transactions, because you might run into some problems if you send a few transactions in a row.
</Warning>

<Note>
The "pending" parameter includes transactions in the mempool that haven't been mined yet. Without it, only confirmed transactions are counted.
</Note>

<Tip>
ethers.js provides a `NonceManager` class that handles nonce tracking automatically:

```javascript
import { NonceManager } from "ethers";
const managedSigner = new NonceManager(signer);
// Now managedSigner tracks nonces automatically
```
</Tip>

### Gaps in Nonces, Duplicate Nonces, and Confirmation

It is important to keep track of nonces if you are creating transactions programmatically, especially if you are doing so from multiple independent processes simultaneously.

The Ethereum network processes transactions sequentially, based on the nonce. That means that if you transmit a transaction with nonce 0 and then transmit a transaction with nonce 2, the second transaction will not be included in any blocks. It will be stored in the mempool, while the Ethereum network waits for the missing nonce to appear. All nodes will assume that the missing nonce has simply been delayed and that the transaction with nonce 2 was received out of sequence.

If you then transmit a transaction with the missing nonce 1, both transactions (nonces 1 and 2) will be processed and included (if valid, of course). Once you fill the gap, the network can mine the out-of-sequence transaction that it held in the mempool.

What this means is that if you create several transactions in sequence and one of them does not get officially included in any blocks, all the subsequent transactions will be "stuck," waiting for the missing nonce. A transaction can create an inadvertent "gap" in the nonce sequence because it is invalid or has insufficient gas. To get things moving again, you have to transmit a valid transaction with the missing nonce.

If, on the other hand, you accidentally duplicate a nonce, for example by transmitting two transactions with the same nonce but different recipients or values, then one of them will be confirmed and one will be rejected. Which one is confirmed will be determined by the sequence in which they arrive at the first validating node that receives them—i.e., it will be fairly random.

### Concurrency, Transaction Origination, and Nonces

Concurrency is a complex aspect of computer science, and it crops up unexpectedly sometimes, especially in decentralized and distributed real-time systems like Ethereum.

In simple terms, concurrency is when you have simultaneous computation by multiple independent systems. These can be in the same program (e.g., multithreading), on the same CPU (e.g., multiprocessing), or on different computers (i.e., distributed systems). Ethereum, by definition, is a system that allows concurrency of operations (nodes, clients, DApps) but enforces a singleton state through consensus.

Now, imagine that you have multiple independent wallet applications that are generating transactions from the same address or addresses. One example of such a situation would be an exchange processing withdrawals from the exchange's hot wallet. Ideally, you'd want to have more than one computer processing withdrawals, so that it doesn't become a bottleneck or single point of failure. However, this quickly becomes problematic, as having more than one computer producing withdrawals will result in some thorny concurrency problems, not least of which is the selection of nonces.

In the end, these concurrency problems, on top of the difficulty of tracking account balances and transaction confirmations in independent processes, force most implementations toward avoiding concurrency and creating bottlenecks such as a single process handling all withdrawal transactions in an exchange, or setting up multiple hot wallets that can work completely independently for withdrawals and only need to be intermittently rebalanced.

## Transaction Types

The EVM has evolved beyond the original transaction format. Today, multiple transaction types coexist, each with different fields and behaviors. Understanding these types is essential for modern EVM development.

### Type 0: Legacy Transactions

The original transaction format, still supported on all EVM chains:

```
{
  nonce,
  gasPrice,
  gasLimit,
  to,
  value,
  data,
  v, r, s  // signature
}
```

Legacy transactions use a single `gasPrice` field: you specify how much you're willing to pay per unit of gas, and miners prioritize transactions with higher gas prices.

### Type 1: Access List Transactions (EIP-2930)

Introduced in the Berlin upgrade (2021), Type 1 transactions add an `accessList` field:

```
{
  chainId,
  nonce,
  gasPrice,
  gasLimit,
  to,
  value,
  data,
  accessList,    // NEW: list of addresses and storage keys
  v, r, s
}
```

The access list declares which addresses and storage slots the transaction will access. This provides gas discounts for "warm" storage access and helps with certain security considerations around gas costs.

### Type 2: EIP-1559 Transactions

The London upgrade (August 2021 on Ethereum) introduced a fundamentally new fee mechanism. Type 2 transactions replace `gasPrice` with two new fields:

```
{
  chainId,
  nonce,
  maxPriorityFeePerGas,  // NEW: tip to block producer
  maxFeePerGas,          // NEW: maximum total fee per gas
  gasLimit,
  to,
  value,
  data,
  accessList,
  v, r, s
}
```

#### How EIP-1559 Fees Work

EIP-1559 introduces a **base fee** that's set by the protocol, not by users:

- **Base fee**: Determined algorithmically based on network congestion. If blocks are more than 50% full, the base fee increases. If less than 50% full, it decreases. This creates predictable pricing.

- **Priority fee (tip)**: An optional tip to incentivize block producers to include your transaction. Goes directly to the miner/validator.

- **Max fee**: The absolute maximum you're willing to pay per gas unit. This protects you from unexpectedly high fees if the base fee spikes.

The actual fee paid is:
```
fee_per_gas = min(maxFeePerGas, baseFee + maxPriorityFeePerGas)
total_fee = fee_per_gas × gas_used
```

Any difference between `maxFeePerGas` and the actual fee is refunded.

#### EIP-1559 on Ethereum: The Fee Burn

On Ethereum, the base fee is **burned**—destroyed forever. Only the priority fee goes to validators. This creates deflationary pressure when network activity is high. During periods of intense usage, more ETH is burned than issued as rewards, making ETH supply deflationary.

```
On Ethereum:
├── Base fee → BURNED (removed from circulation)
└── Priority fee → Validator
```

#### EIP-1559 on Ethereum Classic: Treasury Funding (Olympia)

Ethereum Classic implements EIP-1559 differently through the Olympia upgrade (ECIP-1111). Instead of burning the base fee, ETC directs it to a **treasury address** for protocol development:

```
On Ethereum Classic (post-Olympia):
├── Base fee → Treasury (funds development)
└── Priority fee → Miner
```

<Callout type="note" title="Olympia: Decentralized Funding Without New Issuance">
The Olympia upgrade solves a critical challenge for decentralized networks: how do you fund ongoing development without a central foundation?

By redirecting the base fee to a consensus-recognized treasury (ECIP-1112), ETC creates a sustainable funding mechanism using *existing* transaction fee revenue—no new tokens are minted. Users pay the same fees they would anyway; those fees just go to protocol development instead of being burned.

This is philosophically distinct from ETH's burn (which benefits all holders through scarcity) and from inflationary treasury systems (which dilute existing holders).
</Callout>

#### Code Example: Type 2 Transactions with ethers.js

```javascript
// Modern ethers.js v6 Type 2 transaction
const tx = await signer.sendTransaction({
  to: "0x...",
  value: ethers.parseEther("0.1"),
  // EIP-1559 fields
  maxFeePerGas: ethers.parseUnits("50", "gwei"),
  maxPriorityFeePerGas: ethers.parseUnits("2", "gwei"),
});

// Or let the provider estimate fees
const feeData = await provider.getFeeData();
console.log("Base fee:", ethers.formatUnits(feeData.gasPrice, "gwei"), "gwei");
console.log("Max priority:", ethers.formatUnits(feeData.maxPriorityFeePerGas, "gwei"), "gwei");

// Send with auto-estimated fees
const tx = await signer.sendTransaction({
  to: "0x...",
  value: ethers.parseEther("0.1"),
  // ethers.js automatically uses Type 2 on EIP-1559 networks
});
```

### Type 3: Blob Transactions (EIP-4844)

<Callout type="warning">
Blob transactions are currently only available on Ethereum (since the Dencun upgrade, March 2024). Ethereum Classic, as a proof-of-work chain, does not implement EIP-4844.
</Callout>

The Dencun upgrade introduced Type 3 transactions for Layer 2 rollups:

```
{
  chainId,
  nonce,
  maxPriorityFeePerGas,
  maxFeePerGas,
  gasLimit,
  to,
  value,
  data,
  accessList,
  maxFeePerBlobGas,    // NEW: max fee for blob data
  blobVersionedHashes, // NEW: commitments to blob data
  v, r, s
}
```

Blobs are large data chunks (~128 KB each) attached to transactions but not stored permanently in execution state. They're designed for rollups to post data availability proofs cheaply. Blob data is guaranteed available for ~18 days, then pruned.

Blob transactions have a separate fee market (`blobBaseFee`) that operates independently of the regular gas market.

![Transaction Lifecycle](/images/diagrams/ch06-transaction-flow.svg)

## Transaction Gas

We talked about gas a little in earlier chapters. However, let's cover some basics about the role of gas in transactions.

<Callout type="note">
The following section discusses both the legacy `gasPrice` model and the modern EIP-1559 fee mechanism. On EIP-1559-enabled networks (Ethereum since London 2021, ETC since Olympia 2025), the `maxFeePerGas` and `maxPriorityFeePerGas` fields are preferred. Legacy `gasPrice` transactions are still supported for backward compatibility.
</Callout>

Gas is the fuel of EVM execution. Gas is not ether—it's a separate virtual currency with its own exchange rate against the native currency. EVM networks use gas to control the amount of resources that a transaction can use, since it will be processed on thousands of computers around the world. The open-ended (Turing-complete) computation model requires some form of metering in order to avoid denial-of-service attacks or inadvertently resource-devouring transactions.

Gas is separate from ether in order to protect the system from the volatility that might arise along with rapid changes in the value of ether, and also as a way to manage the important and sensitive ratios between the costs of the various resources that gas pays for (namely, computation, memory, and storage).

The `gasPrice` field in a transaction allows the transaction originator to set the price they are willing to pay in exchange for gas. The price is measured in wei per gas unit.

<Tip>
Various block explorers and gas tracking tools provide real-time information on gas prices and fee estimates for EVM networks.
</Tip>

Wallets can adjust the `gasPrice` in transactions they originate to achieve faster confirmation of transactions. The higher the `gasPrice`, the faster the transaction is likely to be confirmed. Conversely, lower-priority transactions can carry a reduced price, resulting in slower confirmation. The minimum value that `gasPrice` can be set to is zero, which means a fee-free transaction. During periods of low demand for space in a block, such transactions might very well get mined.

<Note>
The minimum acceptable `gasPrice` is zero. That means that wallets can generate completely free transactions. Depending on capacity, these may never be confirmed, but there is nothing in the protocol that prohibits free transactions.
</Note>

The ethers.js interface offers a `gasPrice` suggestion, by querying network fee data:

```javascript
$ npx hardhat console
> const feeData = await ethers.provider.getFeeData()
> feeData.gasPrice
10000000000n
```

The second important field related to gas is `gasLimit`. In simple terms, `gasLimit` gives the maximum number of units of gas the transaction originator is willing to buy in order to complete the transaction. For simple payments, meaning transactions that transfer ether from one EOA to another EOA, the gas amount needed is fixed at 21,000 gas units. To calculate how much ether that will cost, you multiply 21,000 by the `gasPrice` you're willing to pay:

```javascript
> const feeData = await ethers.provider.getFeeData()
> feeData.gasPrice * 21000n
210000000000000n
```

If your transaction's destination address is a contract, then the amount of gas needed can be estimated but cannot be determined with accuracy. That's because a contract can evaluate different conditions that lead to different execution paths, with different total gas costs.

You can think of `gasLimit` as the capacity of the fuel tank in your car (your car is the transaction). You fill the tank with as much gas as you think it will need for the journey (the computation needed to validate your transaction). You can estimate the amount to some degree, but there might be unexpected changes to your journey that increase fuel consumption.

The analogy to a fuel tank is somewhat misleading, however. It's actually more like a credit account for a gas station company, where you pay after the trip is completed, based on how much gas you actually used. When you transmit your transaction, one of the first validation steps is to check that the account it originated from has enough ether to pay the `gasPrice × gasLimit`. But the amount is not actually deducted from your account until the transaction finishes executing. You are only billed for gas actually consumed by your transaction, but you have to have enough balance for the maximum amount you are willing to pay before you send your transaction.

## Transaction Recipient

The recipient of a transaction is specified in the `to` field. This contains a 20-byte Ethereum address. The address can be an EOA or a contract address.

The protocol does no further validation of this field. Any 20-byte value is considered valid. If the 20-byte value corresponds to an address without a corresponding private key, or without a corresponding contract, the transaction is still valid. The protocol has no way of knowing whether an address was correctly derived from a public key (and therefore from a private key) in existence.

<Warning>
The protocol does not validate recipient addresses in transactions. You can send to an address that has no corresponding private key or contract, thereby "burning" the value, rendering it forever unspendable. Validation should be done at the user interface level.
</Warning>

Sending a transaction to the wrong address will probably *burn* the ether sent, rendering it forever inaccessible (unspendable), since most addresses do not have a known private key and therefore no signature can be generated to spend it.

## Transaction Value and Data

The main "payload" of a transaction is contained in two fields: `value` and `data`. Transactions can have both value and data, only value, only data, or neither value nor data. All four combinations are valid.

A transaction with only value is a *payment*. A transaction with only data is an *invocation*. A transaction with both value and data is both a payment and an invocation. A transaction with neither value nor data—well that's probably just a waste of gas! But it is still possible.

Let's try all of these combinations using ethers.js in the Hardhat console. First we'll get our signers:

```javascript
const [src, dst] = await ethers.getSigners();
```

Our first transaction contains only a value (payment), and no data payload:

```javascript
await src.sendTransaction({
  to: dst.address,
  value: ethers.parseEther("0.01")
});
```

The next example specifies both a value and a data payload:

```javascript
await src.sendTransaction({
  to: dst.address,
  value: ethers.parseEther("0.01"),
  data: "0x1234"
});
```

The next transaction includes a data payload but specifies a value of zero:

```javascript
await src.sendTransaction({
  to: dst.address,
  value: 0n,
  data: "0x1234"
});
```

This is common when calling contract functions that don't require payment.

Finally, the last transaction includes neither a value to send nor a data payload:

```javascript
await src.sendTransaction({
  to: dst.address,
  value: 0n,
  data: "0x"
});
```

This transaction is valid but doesn't accomplish much — it just costs gas.

### Transmitting Value to EOAs and Contracts

When you construct an Ethereum transaction that contains a value, it is the equivalent of a *payment*. Such transactions behave differently depending on whether the destination address is a contract or not.

For EOA addresses, or rather for any address that isn't flagged as a contract on the blockchain, Ethereum will record a state change, adding the value you sent to the balance of the address. If the address has not been seen before, it will be added to the client's internal representation of the state and its balance initialized to the value of your payment.

If the destination address (`to`) is a contract, then the EVM will execute the contract and will attempt to call the function named in the data payload of your transaction. If there is no data in your transaction, the EVM will call a *fallback* function and, if that function is payable, will execute it to determine what to do next. If there is no code in fallback function, then the effect of the transaction will be to increase the balance of the contract, exactly like a payment to a wallet. If there is no fallback function or non-payable fallback function, then transaction will be reverted.

A contract can reject incoming payments by throwing an exception immediately when a function is called, or as determined by conditions coded in a function. If the function terminates successfully (without an exception), then the contract's state is updated to reflect an increase in the contract's ether balance.

### Transmitting a Data Payload to an EOA or Contract

When your transaction contains data, it is most likely addressed to a contract address. That doesn't mean you cannot send a data payload to an EOA—that is completely valid in the protocol. However, in that case, the interpretation of the data is up to the wallet you use to access the EOA. It is ignored by the protocol. Most wallets also ignore any data received in a transaction to an EOA they control.

For now, let's assume your transaction is delivering data to a contract address. In that case, the data will be interpreted by the EVM as a *contract invocation*. Most contracts use this data more specifically as a *function invocation*, calling the named function and passing any encoded arguments to the function.

The data payload sent to an ABI-compatible contract is a hex-serialized encoding of:

**A function selector** — The first 4 bytes of the Keccak-256 hash of the function's prototype. This allows the contract to unambiguously identify which function you wish to invoke.

**The function arguments** — The function's arguments, encoded according to the rules for the various elementary types defined in the ABI specification.

In our Faucet example, we defined a function for withdrawals:

```solidity
function withdraw(uint withdraw_amount) public {
```

The *prototype* of a function is defined as the string containing the name of the function, followed by the data types of each of its arguments, enclosed in parentheses and separated by commas. The function name here is `withdraw` and it takes a single argument that is a `uint` (which is an alias for `uint256`), so the prototype of `withdraw` would be:

```solidity
withdraw(uint256)
```

Let's calculate the Keccak-256 hash of this string using ethers.js:

```javascript
> ethers.keccak256(ethers.toUtf8Bytes("withdraw(uint256)"))
'0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f'
```

The first 4 bytes of the hash are `0x2e1a7d4d`. That's our "function selector" value, which will tell the contract which function we want to call.

Next, let's calculate a value to pass as the argument `withdraw_amount`. We want to withdraw 0.01 ether. Let's encode that to a hex-serialized big-endian unsigned 256-bit integer, denominated in wei:

```javascript
> const withdrawAmount = ethers.parseEther("0.01")
> withdrawAmount.toString()
'10000000000000000'
> ethers.toBeHex(withdrawAmount)
'0x2386f26fc10000'
```

Now, we add the function selector to the amount (padded to 32 bytes):

```
2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000
```

That's the data payload for our transaction, invoking the `withdraw` function and requesting 0.01 ether as the `withdraw_amount`.

## Special Transaction: Contract Creation

One special case that we should mention is a transaction that *creates a new contract* on the blockchain, deploying it for future use. Contract creation transactions are sent to a special destination address called the *zero address*; the `to` field in a contract registration transaction contains the address `0x0`. This address represents neither an EOA (there is no corresponding private–public key pair) nor a contract. It can never spend ether or initiate a transaction. It is only used as a destination, with the special meaning "create this contract."

While the zero address is intended only for contract creation, it sometimes receives payments from various addresses. There are two explanations for this: either it is by accident, resulting in the loss of ether, or it is an intentional *ether burn* (deliberately destroying ether by sending it to an address from which it can never be spent). However, if you want to do an intentional ether burn, you should make your intention clear to the network and use the specially designated burn address instead:

```
0x000000000000000000000000000000000000dEaD
```

<Warning>
Any ether sent to the designated burn address will become unspendable and be lost forever.
</Warning>

A contract creation transaction need only contain a data payload that contains the compiled bytecode which will create the contract. The only effect of this transaction is to create the contract. You can include an ether amount in the `value` field if you want to set the new contract up with a starting balance, but that is entirely optional.

## Digital Signatures

So far, we have not delved into any detail about digital signatures. In this section, we look at how digital signatures work and how they can be used to present proof of ownership of a private key without revealing that private key.

### The Elliptic Curve Digital Signature Algorithm

The digital signature algorithm used in Ethereum is the *Elliptic Curve Digital Signature Algorithm* (ECDSA). It's based on elliptic curve private–public key pairs, as described in the Cryptography chapter.

A digital signature serves three purposes in Ethereum. First, the signature proves that the owner of the private key, who is by implication the owner of an Ethereum account, has *authorized* the spending of ether, or execution of a contract. Secondly, it guarantees *non-repudiation*: the proof of authorization is undeniable. Thirdly, the signature proves that the transaction data has not been and *cannot be modified* by anyone after the transaction has been signed.

### How Digital Signatures Work

A digital signature is a mathematical scheme that consists of two parts. The first part is an algorithm for creating a signature, using a private key (the signing key), from a message (which in our case is the transaction). The second part is an algorithm that allows anyone to verify the signature by only using the message and a public key.

#### Creating a digital signature

In Ethereum's implementation of ECDSA, the "message" being signed is the transaction, or more accurately, the Keccak-256 hash of the RLP-encoded data from the transaction. The signing key is the EOA's private key. The result is the signature:

**Sig = F_sig(F_keccak256(m), k)**

where:

- *k* is the signing private key
- *m* is the RLP-encoded transaction
- *F_keccak256* is the Keccak-256 hash function
- *F_sig* is the signing algorithm
- *Sig* is the resulting signature

The function *F_sig* produces a signature *Sig* that is composed of two values, commonly referred to as *r* and *s*:

**Sig = (r, s)**

### Verifying the Signature

To verify the signature, one must have the signature (*r* and *s*), the serialized transaction, and the public key that corresponds to the private key used to create the signature. Essentially, verification of a signature means "only the owner of the private key that generated this public key could have produced this signature on this transaction."

The signature verification algorithm takes the message (i.e., a hash of the transaction for our usage), the signer's public key, and the signature (*r* and *s* values), and returns `true` if the signature is valid for this message and public key.

### Transaction Signing in Practice

To produce a valid transaction, the originator must digitally sign the message, using the Elliptic Curve Digital Signature Algorithm. When we say "sign the transaction" we actually mean "sign the Keccak-256 hash of the RLP-serialized transaction data." The signature is applied to the hash of the transaction data, not the transaction itself.

To sign a transaction in Ethereum, the originator must:

1. Create a transaction data structure, containing nine fields: `nonce`, `gasPrice`, `gasLimit`, `to`, `value`, `data`, `chainID`, `0`, `0`.
2. Produce an RLP-encoded serialized message of the transaction data structure.
3. Compute the Keccak-256 hash of this serialized message.
4. Compute the ECDSA signature, signing the hash with the originating EOA's private key.
5. Append the ECDSA signature's computed `v`, `r`, and `s` values to the transaction.

The special signature variable `v` indicates two things: the chain ID and the recovery identifier to help the `ECDSArecover` function check the signature.

<Note>
At block #2,675,000 Ethereum implemented the "Spurious Dragon" hard fork, which, among other changes, introduced a new signing scheme that includes transaction replay protection (preventing transactions meant for one network being replayed on others). This new signing scheme is specified in EIP-155.
</Note>

### Raw Transaction Creation with EIP-155

The EIP-155 "Simple Replay Attack Protection" standard specifies a replay-attack-protected transaction encoding, which includes a *chain identifier* inside the transaction data, prior to signing. This ensures that transactions created for one blockchain (e.g., the Ethereum main network) are invalid on another blockchain (e.g., Ethereum Classic or the Sepolia test network). Therefore, transactions broadcast on one network cannot be *replayed* on another, hence the name of the standard.

The chain identifier field takes a value according to the network the transaction is meant for:

| Chain | Chain ID | Consensus |
|-------|----------|-----------|
| Ethereum mainnet | 1 | Proof of Stake |
| Ethereum Classic mainnet | 61 | Proof of Work |
| Sepolia (ETH testnet) | 11155111 | Proof of Stake |
| Holesky (ETH testnet) | 17000 | Proof of Stake |
| Mordor (ETC testnet) | 63 | Proof of Work |
| Rootstock mainnet | 30 | Merge-mined with Bitcoin |
| Rootstock testnet | 31 | Merge-mined with Bitcoin |
| Hardhat local | 31337 | Local dev network |
| Anvil local | 31337 | Local dev network |

<Note>
The deprecated testnets Ropsten (3), Rinkeby (4), and Kovan (42) are no longer maintained. Use Sepolia for Ethereum development or Mordor for Ethereum Classic development.
</Note>

## The Signature Prefix Value (v) and Public Key Recovery

As mentioned earlier, the transaction message doesn't include a "from" field. That's because the originator's public key can be computed directly from the ECDSA signature. Once you have the public key, you can compute the address easily. The process of recovering the signer's public key is called *public key recovery*.

Given the values `r` and `s` that were computed in the signature, we can compute two possible public keys.

First, we compute two elliptic curve points, *R* and *R'*, from the *x* coordinate `r` value that is in the signature. There are two points because the elliptic curve is symmetric across the x-axis, so that for any value `x` there are two possible values that fit the curve, one on each side of the x-axis.

To make things more efficient, the transaction signature includes a prefix value `v`, which tells us which of the two possible *R* values is the ephemeral public key. If `v` is even, then *R* is the correct value. If `v` is odd, then it is *R'*. That way, we need to calculate only one value for *R* and only one value for *K*.

## Separating Signing and Transmission (Offline Signing)

Once a transaction is signed, it is ready to transmit to the Ethereum network. The three steps of creating, signing, and broadcasting a transaction normally happen as a single operation, for example using `signer.sendTransaction()` in ethers.js. However, you can create and sign the transaction in two separate steps. Once you have a signed transaction, you can then broadcast it using `provider.broadcastTransaction()`, which takes a serialized signed transaction and transmits it on the Ethereum network.

Why would you want to separate the signing and transmission of transactions? The most common reason is security. The computer that signs a transaction must have unlocked private keys loaded in memory. The computer that does the transmitting must be connected to the internet (and be running an Ethereum client). If these two functions are on one computer, then you have private keys on an online system, which is quite dangerous. Separating the functions of signing and transmitting and performing them on different machines (on an offline and an online device, respectively) is called *offline signing* and is a common security practice.

The process:

1. Create an unsigned transaction on the online computer where the current state of the account, notably the current nonce and funds available, can be retrieved.
2. Transfer the unsigned transaction to an "air-gapped" offline device for transaction signing, e.g., via a QR code or USB flash drive.
3. Transmit the signed transaction (back) to an online device for broadcast on the Ethereum blockchain, e.g., via QR code or USB flash drive.

Depending on the level of security you need, your "offline signing" computer can have varying degrees of separation from the online computer, ranging from an isolated and firewalled subnet (online but segregated) to a completely offline system known as an *air-gapped* system. In an air-gapped system there is no network connectivity at all—the computer is separated from the online environment by a gap of "air."

## Transaction Propagation

The Ethereum network uses a "flood routing" protocol. Each Ethereum client acts as a *node* in a *peer-to-peer (P2P)* network, which (ideally) forms a *mesh* network. No network node is special: they all act as equal peers.

Transaction propagation starts with the originating Ethereum node creating (or receiving from offline) a signed transaction. The transaction is validated and then transmitted to all the other Ethereum nodes that are *directly* connected to the originating node. On average, each Ethereum node maintains connections to at least 13 other nodes, called its *neighbors*. Each neighbor node validates the transaction as soon as they receive it. If they agree that it is valid, they store a copy and propagate it to all their neighbors (except the one it came from). As a result, the transaction ripples outwards from the originating node, *flooding* across the network, until all nodes in the network have a copy of the transaction.

Within just a few seconds, an Ethereum transaction propagates to all the Ethereum nodes around the globe. From the perspective of each node, it is not possible to discern the origin of the transaction. The neighbor that sent it to the node may be the originator of the transaction or may have received it from one of its neighbors. This is part of the security and privacy design of P2P networks.

## Recording on the Blockchain

While all the nodes in Ethereum are equal peers, some of them are operated by *block producers* — miners on Proof of Work chains (like Ethereum Classic) or validators on Proof of Stake chains (like Ethereum). These block producers add transactions to candidate blocks and compete to have their blocks accepted by the network.

<Note>
On **Ethereum Classic (PoW)**, miners use GPUs to find a proof of work that makes blocks valid. On **Ethereum (PoS)**, validators stake 32 ETH and are randomly selected to propose and attest to blocks. Despite different consensus mechanisms, the transaction processing and EVM execution are identical.
</Note>

Without going into too much detail, valid transactions will eventually be included in a block of transactions and, thus, recorded in the blockchain. Once included in a block, transactions also modify the state of the Ethereum singleton, either by modifying the balance of an account (in the case of a simple payment) or by invoking contracts that change their internal state. These changes are recorded alongside the transaction, in the form of a transaction *receipt*, which may also include *events*.

A transaction that has completed its journey from creation through signing by an EOA, propagation, and finally inclusion in a block has changed the state of the singleton and left an indelible mark on the blockchain.

## Maximal Extractable Value (MEV)

MEV (Maximal Extractable Value, formerly "Miner Extractable Value") refers to the profit that block producers can capture by reordering, inserting, or censoring transactions within a block.

### How MEV Works

Because block producers control transaction ordering, they can:

1. **Front-run**: Insert their transaction before a profitable user transaction
2. **Back-run**: Insert their transaction immediately after a profitable opportunity
3. **Sandwich**: Place transactions both before and after a victim's trade
4. **Arbitrage**: Capture price differences across DEXs
5. **Liquidations**: Race to liquidate undercollateralized positions

```
Normal mempool order:     [Tx1] [Tx2] [Tx3] [Tx4]

Front-running:           [Attacker] [Victim] [Tx1] [Tx2]
                              ↑ Attacker buys before victim's large buy

Sandwich attack:         [Buy] [Victim] [Sell] [Tx1]
                           ↑              ↑
                     Attacker buys   Attacker sells
                     before victim   after victim
```

### MEV on Different Consensus Mechanisms

**Proof of Work (ETC)**:
- Miners control transaction ordering
- Mining pools may run MEV extraction
- Less sophisticated MEV infrastructure than Ethereum

**Proof of Stake (ETH)**:
- Validators propose blocks but often delegate to *builders*
- PBS (Proposer-Builder Separation) creates a market for block building
- MEV-Boost connects validators to block builders

```
ETH Block Production (post-PBS):

Searchers → find MEV opportunities → send bundles to
    ↓
Builders → construct optimal blocks → bid to
    ↓
Validators → select highest-bidding block → propose to network
```

### The MEV Supply Chain

| Actor | Role | Example |
|-------|------|---------|
| **Searchers** | Find MEV opportunities | Arbitrage bots, liquidation bots |
| **Builders** | Construct blocks from transactions | Flashbots, bloXroute, Titan |
| **Relays** | Connect builders to validators | Flashbots Relay, Ultrasound |
| **Validators** | Propose blocks | Lido, Coinbase, independent |

### Protecting Against MEV

#### 1. Private Mempools (Flashbots Protect)

Instead of broadcasting to the public mempool, send transactions privately:

```typescript
import { createWalletClient, http } from 'viem'
import { mainnet } from 'viem/chains'

// Use Flashbots Protect RPC
const client = createWalletClient({
  chain: mainnet,
  transport: http('https://rpc.flashbots.net'),
})

// Transactions sent here won't be visible in public mempool
const hash = await client.sendTransaction({
  to: '0x...',
  value: parseEther('1'),
})
```

<Callout type="info">
**Flashbots Protect** routes your transaction directly to block builders, bypassing the public mempool. If your transaction would be unprofitable to include (not enough gas), it may take longer to confirm.
</Callout>

#### 2. Slippage Protection

For DEX trades, set appropriate slippage tolerance:

```solidity
// Uniswap-style swap with slippage protection
function swapExactTokensForTokens(
    uint amountIn,
    uint amountOutMin,    // Minimum acceptable output
    address[] calldata path,
    address to,
    uint deadline
) external returns (uint[] memory amounts);
```

Set `amountOutMin` to protect against sandwich attacks:

```typescript
// Calculate minimum output with 0.5% slippage
const amountOutMin = expectedOutput * 995n / 1000n
```

#### 3. Commit-Reveal Schemes

For high-value operations, use commit-reveal to hide intent:

```solidity
// Phase 1: Commit (hash of action + secret)
function commit(bytes32 commitment) external {
    commitments[msg.sender] = commitment;
    commitTime[msg.sender] = block.timestamp;
}

// Phase 2: Reveal (after some blocks)
function reveal(uint256 action, bytes32 secret) external {
    require(block.timestamp > commitTime[msg.sender] + COMMIT_DELAY);
    require(keccak256(abi.encode(action, secret)) == commitments[msg.sender]);
    // Execute action
}
```

#### 4. Time-Weighted Average Prices (TWAP)

For large trades, execute over time to reduce impact:

```solidity
// Execute trade in chunks over multiple blocks
function twapSwap(
    uint256 totalAmount,
    uint256 chunks,
    uint256 intervalBlocks
) external {
    uint256 chunkSize = totalAmount / chunks;
    // Queue chunks for execution over time
}
```

### MEV and Protocol Design

When designing protocols, consider MEV implications:

**Bad**: Relying on transaction ordering for fairness
```solidity
// VULNERABLE: First caller wins
function claim() external {
    require(!claimed);
    claimed = true;
    token.transfer(msg.sender, reward);
}
```

**Better**: Use commit-reveal or randomness
```solidity
// Fairer: Random selection from committed participants
function selectWinner() external {
    bytes32 randomness = keccak256(abi.encode(
        block.prevrandao,
        block.timestamp,
        participants.length
    ));
    uint256 winnerIndex = uint256(randomness) % participants.length;
    // ...
}
```

### The Ethics of MEV

MEV is controversial:

**Arguments for MEV**:
- Market efficiency: Arbitrage keeps prices aligned
- Protocol health: Liquidations prevent bad debt
- Block producer revenue: Sustainable validator economics

**Arguments against MEV**:
- User harm: Sandwich attacks cost users money
- Centralization: MEV infrastructure benefits sophisticated actors
- Network stability: MEV can incentivize reorgs

The ecosystem has evolved toward "MEV redistribution" — extracting MEV but returning value to users through better prices, lower fees, or protocol mechanisms.

## Multiple-Signature (Multisig) Transactions

If you are familiar with Bitcoin's scripting capabilities, you know that it is possible to create a Bitcoin multisig account which can only spend funds when multiple parties sign the transaction (e.g., 2 of 2 or 3 of 4 signatures). Ethereum's basic EOA value transactions have no provisions for multiple signatures; however, arbitrary signing restrictions can be enforced by smart contracts with any conditions you can think of, to handle the transfer of ether and tokens alike.

To take advantage of this capability, ether has to be transferred to a "wallet contract" that is programmed with the spending rules desired, such as multisignature requirements or spending limits (or combinations of the two). The wallet contract then sends the funds when prompted by an authorized EOA once the spending conditions have been satisfied.

The ability to implement multisignature transactions as a smart contract demonstrates the flexibility of Ethereum. However, it is a double-edged sword, as the extra flexibility can lead to bugs that undermine the security of multisignature schemes. There are, in fact, a number of proposals to create a multisignature command in the EVM that removes the need for smart contracts, at least for the simple M-of-N multisignature schemes.

## Conclusions

Transactions are the starting point of every activity in the Ethereum system. Transactions are the "inputs" that cause the Ethereum Virtual Machine to evaluate contracts, update balances, and more generally modify the state of the Ethereum blockchain. Next, we will work with smart contracts in a lot more detail and learn how to program in the Solidity contract-oriented language.
