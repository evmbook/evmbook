---
title: EVM Internals
description: Understanding the Ethereum Virtual Machine at the bytecode level
chapter: 13
---

# The EVM in Depth

The Ethereum Virtual Machine (EVM) is the runtime environment for smart contracts. Understanding how the EVM works at a low level helps you write more efficient contracts, debug complex issues, and understand security vulnerabilities.

## Smart Contract Origins

The concept of smart contracts predates cryptocurrency by over a decade. **Nick Szabo** first described the concept in 1994, envisioning "a set of promises, specified in digital form, including protocols within which the parties perform on these promises." His 1996 paper "Smart Contracts: Building Blocks for Digital Markets" provided the theoretical foundation that would later inspire Ethereum. [@szabo_smart_contracts_1996]

### Pre-Ethereum Attempts

Before Ethereum, several projects attempted programmable blockchain functionality:

| Project | Year | Approach | Limitation |
|---------|------|----------|------------|
| **Bitcoin Script** | 2009 | Stack-based, intentionally limited | Not Turing-complete by design |
| **Namecoin** | 2011 | First alt-chain, DNS-like registry | Single-purpose scripting |
| **Mastercoin/Omni** | 2013 | Colored coins on Bitcoin | Limited by OP_RETURN constraints |
| **Counterparty** | 2014 | Smart contracts via OP_RETURN | 80-byte data limit per transaction |
| **NXT** | 2013 | First pure PoS with scripting | Limited scripting capabilities |

Bitcoin's Script language was intentionally constrained—Satoshi removed several opcodes early on to prevent potential attack vectors. This limitation sparked the search for a more expressive platform.

<Callout type="info">
**Counterparty's Innovation**: In 2014, Counterparty embedded a Turing-complete virtual machine on Bitcoin using OP_RETURN. While functional, the 80-byte data limit per transaction made complex contracts impractical—a limitation that directly motivated Ethereum's design.
</Callout>

### The Ethereum Solution

Vitalik Buterin's 2013 whitepaper proposed a fundamentally different approach: a blockchain with a built-in Turing-complete programming language. The key insight was that instead of building specialized features (like Namecoin's DNS or Mastercoin's tokens), you could build a general-purpose platform where any application could be created through smart contracts. [@buterin_ethereum_2014]

Gavin Wood's Yellow Paper (2014) formally specified the EVM, defining every opcode, gas cost, and state transition rule with mathematical precision. This specification enabled multiple independent client implementations—a crucial factor in Ethereum's resilience. [@wood_ethereum_yellow_2014]

## EVM Architecture

The EVM is a stack-based, 256-bit virtual machine. Key characteristics:

- **Stack-based** — Operations push and pop values from a stack
- **256-bit word size** — All values are 256 bits (32 bytes)
- **Deterministic** — Same input always produces same output
- **Isolated** — Contracts can't access other contracts' storage directly
- **Metered** — Every operation costs gas

### Memory Model

The EVM has three main data locations:

**Stack** — Temporary values during computation (max 1024 elements)

**Memory** — Byte-addressable, volatile storage (cleared after execution)

**Storage** — Persistent key-value store (256-bit keys, 256-bit values)

```
┌─────────────────────────────────────────────────────────────┐
│                         EVM                                  │
├─────────────────┬─────────────────┬────────────────────────┤
│     Stack       │     Memory      │       Storage          │
│  (1024 x 256)   │  (byte array)   │  (key → value map)     │
│  • Temporary    │  • Volatile     │  • Persistent          │
│  • Fast         │  • Expandable   │  • Expensive           │
│  • Free         │  • Cheap        │  • 20,000 gas to set   │
└─────────────────┴─────────────────┴────────────────────────┘
```

### The Stack

Most EVM operations work on the stack:

```
PUSH1 0x60    // Push 0x60 onto stack
PUSH1 0x40    // Push 0x40 onto stack
MSTORE        // Store 0x60 at memory location 0x40

Stack before MSTORE: [0x40, 0x60]
Stack after MSTORE:  []
```

The stack is limited to 1024 elements. Stack overflow causes the transaction to fail.

### Memory

Memory is a byte array that expands as needed:

```
MLOAD   - Load 32 bytes from memory
MSTORE  - Store 32 bytes to memory
MSTORE8 - Store 1 byte to memory
```

Memory expansion costs gas based on how much is used. The cost grows quadratically with size.

### Storage

Storage persists between transactions. It's the most expensive data location:

```
SLOAD  - Load from storage (2,100 gas cold / 100 gas warm)
SSTORE - Store to storage (20,000 gas new / 5,000 gas update)
```

Each contract has its own storage space, isolated from other contracts.

![EVM Architecture](/images/diagrams/ch13-evm-architecture.svg)

## EVM Opcodes

Opcodes are the machine instructions of the EVM. Here are the major categories:

### Stack Operations

| Opcode | Description |
|--------|-------------|
| `PUSH1`-`PUSH32` | Push N bytes onto stack |
| `POP` | Remove top stack item |
| `DUP1`-`DUP16` | Duplicate Nth stack item |
| `SWAP1`-`SWAP16` | Swap top with Nth stack item |

### Arithmetic

| Opcode | Description |
|--------|-------------|
| `ADD` | Addition |
| `MUL` | Multiplication |
| `SUB` | Subtraction |
| `DIV` | Integer division |
| `MOD` | Modulo |
| `EXP` | Exponentiation |
| `ADDMOD` | Modular addition |
| `MULMOD` | Modular multiplication |

### Comparison & Bitwise

| Opcode | Description |
|--------|-------------|
| `LT`, `GT` | Less than, greater than |
| `SLT`, `SGT` | Signed comparison |
| `EQ` | Equality |
| `ISZERO` | Check if zero |
| `AND`, `OR`, `XOR`, `NOT` | Bitwise operations |
| `SHL`, `SHR`, `SAR` | Bit shifting |

### Memory & Storage

| Opcode | Description |
|--------|-------------|
| `MLOAD` | Load word from memory |
| `MSTORE` | Store word to memory |
| `MSTORE8` | Store byte to memory |
| `MCOPY` | Copy memory region (EIP-5656) |
| `SLOAD` | Load word from storage |
| `SSTORE` | Store word to storage |
| `TLOAD` | Load from transient storage (EIP-1153) |
| `TSTORE` | Store to transient storage (EIP-1153) |

### Contract Interaction

| Opcode | Description |
|--------|-------------|
| `CALL` | Call another contract |
| `DELEGATECALL` | Call with current context |
| `STATICCALL` | Read-only call |
| `CREATE` | Deploy new contract |
| `CREATE2` | Deploy with deterministic address |
| `SELFDESTRUCT` | Destroy contract (see note below) |

<Callout type="warning">
**SELFDESTRUCT Changes (EIP-6780)**: Since the Cancun upgrade on Ethereum, `SELFDESTRUCT` only destroys contract state if called in the **same transaction** as contract creation. Otherwise, it only transfers the contract's balance to the target without deleting code or storage. ETC will adopt similar semantics in a future upgrade. For reentrancy guards and similar patterns, use transient storage (`TSTORE`/`TLOAD`) instead.
</Callout>

### New Opcodes (2023-2025)

Recent upgrades introduced important new opcodes:

| Opcode | Hex | Description | Available |
|--------|-----|-------------|-----------|
| `PUSH0` | 0x5F | Push zero to stack (saves 1 gas vs `PUSH1 0x00`) | ETH Shanghai, ETC Olympia |
| `MCOPY` | 0x5E | Memory-to-memory copy | ETH Cancun, ETC Olympia |
| `TLOAD` | 0x5C | Load from transient storage | ETH Cancun, ETC Olympia |
| `TSTORE` | 0x5D | Store to transient storage | ETH Cancun, ETC Olympia |
| `BASEFEE` | 0x48 | Current block base fee (EIP-1559) | ETH London, ETC Olympia |
| `BLOBHASH` | 0x49 | Get blob versioned hash | ETH Cancun only |
| `BLOBBASEFEE` | 0x4A | Get blob base fee | ETH Cancun only |

#### PUSH0 (EIP-3855)

Pushes zero onto the stack for 2 gas instead of 3 gas for `PUSH1 0x00`:

```
// Old: 3 gas
PUSH1 0x00

// New: 2 gas
PUSH0
```

Solidity 0.8.20+ generates `PUSH0` by default. This saves gas across many common patterns (function argument padding, zero initialization, etc.).

#### Transient Storage (EIP-1153)

Transient storage is automatically cleared at the end of each transaction—perfect for reentrancy locks:

```solidity
// Using transient storage for reentrancy guard
contract ReentrancyGuard {
    uint256 private constant LOCKED = 2;
    uint256 private constant UNLOCKED = 1;

    modifier nonReentrant() {
        // TLOAD: Read transient storage
        assembly { if eq(tload(0), LOCKED) { revert(0, 0) } }

        // TSTORE: Set lock
        assembly { tstore(0, LOCKED) }
        _;
        // TSTORE: Clear lock (automatically cleared at tx end anyway)
        assembly { tstore(0, UNLOCKED) }
    }
}
```

Benefits:
- 100 gas for `TLOAD`/`TSTORE` vs 2,100/20,000 for `SLOAD`/`SSTORE`
- No need to clear at end (automatic)
- Perfect for per-transaction state

#### MCOPY (EIP-5656)

Efficient memory-to-memory copy:

```solidity
// Old approach: loop with MLOAD/MSTORE
assembly {
    let length := mload(data)
    let src := add(data, 32)
    let dest := result
    for { let i := 0 } lt(i, length) { i := add(i, 32) } {
        mstore(add(dest, i), mload(add(src, i)))
    }
}

// New approach: single MCOPY instruction
assembly {
    mcopy(dest, src, length)
}
```

<Note>
**ETC Opcode Parity (ECIP-1121)**: The Olympia upgrade brings all these opcodes to Ethereum Classic, ensuring contracts compiled for recent Ethereum versions work correctly on ETC. `BLOBHASH` and `BLOBBASEFEE` are included for bytecode compatibility but return zero since ETC doesn't support blob transactions.
</Note>

### Block Information

| Opcode | Description |
|--------|-------------|
| `BLOCKHASH` | Hash of a recent block |
| `COINBASE` | Block producer address |
| `TIMESTAMP` | Block timestamp |
| `NUMBER` | Block number |
| `DIFFICULTY` / `PREVRANDAO` | PoW difficulty or PoS randomness |
| `GASLIMIT` | Block gas limit |
| `CHAINID` | Current chain ID (1 for ETH, 61 for ETC) |
| `BASEFEE` | Current block base fee (EIP-1559/EIP-3198) |

<Note>
The `DIFFICULTY` opcode returns different values on **Ethereum Classic (PoW)** vs **Ethereum (PoS)**. After The Merge, Ethereum renamed it to `PREVRANDAO` and it returns random data from the beacon chain instead of mining difficulty.
</Note>

<Note>
**BASEFEE** returns the current block's base fee. On Ethereum, the base fee is burned; on Ethereum Classic (post-Olympia), it goes to the protocol treasury. Contracts can use this for gas price estimation and fee-aware logic.
</Note>

## Gas Mechanics

Every opcode has a gas cost. Simple operations are cheap, complex operations are expensive:

| Operation | Gas Cost |
|-----------|----------|
| `ADD`, `SUB` | 3 |
| `MUL`, `DIV` | 5 |
| `SLOAD` (cold) | 2,100 |
| `SLOAD` (warm) | 100 |
| `SSTORE` (new) | 20,000 |
| `SSTORE` (update) | 5,000 |
| `CALL` (cold) | 2,600 |
| `CREATE` | 32,000 |

### Gas Refunds

Some operations provide refunds:
- Setting storage to zero: 4,800 gas refund
- `SELFDESTRUCT`: 24,000 gas refund (deprecated)

### EIP-2929 Access Lists

Introduced "cold" and "warm" storage:
- First access to an address/slot is "cold" (expensive)
- Subsequent accesses are "warm" (cheaper)

```solidity
// First access: cold (2,100 gas)
uint256 a = someMapping[key];

// Second access: warm (100 gas)
uint256 b = someMapping[key];
```

## Bytecode Analysis

### Disassembling Contracts

Use tools to analyze bytecode:

```bash
# With cast (Foundry)
cast disassemble 0x608060405234801561001057600080fd5b...

# Output:
# 0x0000: PUSH1 0x80
# 0x0002: PUSH1 0x40
# 0x0004: MSTORE
# ...
```

### Contract Creation Code

When you deploy a contract, you actually send "creation code" that returns the "runtime code":

```
┌────────────────────────────────────────────────────────────┐
│                    Creation Code                           │
│  ┌──────────────────┐  ┌─────────────────────────────────┐ │
│  │  Initialization  │  │       Runtime Code              │ │
│  │  (constructor)   │  │  (actual contract logic)        │ │
│  └──────────────────┘  └─────────────────────────────────┘ │
└────────────────────────────────────────────────────────────┘
           │                          │
           ▼                          ▼
       Executed once            Stored on-chain
```

### Function Selectors

Functions are identified by the first 4 bytes of their keccak256 hash:

```javascript
// "transfer(address,uint256)"
keccak256("transfer(address,uint256)") = 0xa9059cbb...
// First 4 bytes: 0xa9059cbb
```

The runtime code typically starts with a dispatcher:

```
CALLDATALOAD  // Get first 32 bytes of calldata
PUSH1 0xe0
SHR           // Shift right to get first 4 bytes
DUP1
PUSH4 0xa9059cbb  // transfer selector
EQ
PUSH2 0x0123  // Jump destination
JUMPI         // Jump if match
// ... more function checks
```

## Writing Inline Assembly

Solidity allows inline assembly (Yul) for low-level operations:

```solidity
function addNumbers(uint256 a, uint256 b) public pure returns (uint256 result) {
    assembly {
        result := add(a, b)
    }
}

function efficientCopy(bytes memory data) public pure returns (bytes32) {
    bytes32 result;
    assembly {
        result := mload(add(data, 32))  // Skip length prefix
    }
    return result;
}
```

### When to Use Assembly

✅ Use for:
- Gas optimization in hot paths
- Operations not available in Solidity
- Low-level memory manipulation

❌ Avoid for:
- Most contract logic (use Solidity)
- Anything a junior developer needs to maintain
- Unless you truly need the optimization

## Gas Optimization Patterns

### Storage Packing

Pack multiple values into single storage slots:

```solidity
// Bad: Uses 3 storage slots
contract Unpacked {
    uint256 a;  // Slot 0
    uint256 b;  // Slot 1
    uint256 c;  // Slot 2
}

// Good: Uses 1 storage slot
contract Packed {
    uint128 a;  // Slot 0 (lower 128 bits)
    uint64 b;   // Slot 0 (next 64 bits)
    uint64 c;   // Slot 0 (upper 64 bits)
}
```

### Caching Storage Reads

```solidity
// Bad: Multiple SLOAD operations
function sum() public view returns (uint256) {
    return values[0] + values[1] + values[2];  // 3 SLOADs
}

// Good: Cache in memory
function sum() public view returns (uint256) {
    uint256 v0 = values[0];  // 1 SLOAD
    uint256 v1 = values[1];  // 1 SLOAD
    uint256 v2 = values[2];  // 1 SLOAD
    return v0 + v1 + v2;     // Operations on memory are cheap
}
```

### Using `unchecked` for Safe Math

```solidity
// When you know overflow is impossible
function increment(uint256 i) public pure returns (uint256) {
    unchecked {
        return i + 1;  // Saves ~30 gas by skipping overflow check
    }
}
```

### Short-Circuit Evaluation

```solidity
// Put cheaper conditions first
if (cheapCheck && expensiveCheck) { ... }

// Put likely-false conditions first
if (likely_false || likely_true) { ... }
```

## Debugging at the EVM Level

### Using Foundry's Debugger

```bash
forge test --debug "testMyFunction"
```

This opens an interactive debugger showing:
- Current opcode
- Stack contents
- Memory contents
- Storage changes
- Gas usage

### Trace Analysis

```bash
cast run <txhash> --trace
```

Shows the complete execution trace of a transaction.

## EVM Client Implementations

Unlike centralized systems, the EVM has multiple independent implementations. This client diversity is crucial for network resilience—a bug in one client doesn't take down the entire network.

### Major EVM Clients

| Client | Language | Focus | Usage |
|--------|----------|-------|-------|
| **Geth** | Go | Reference implementation | ~55% of ETH nodes |
| **Erigon** | Go | Archive nodes, efficiency | Growing adoption |
| **Nethermind** | C# | Enterprise, .NET ecosystem | ~15% of ETH nodes |
| **Besu** | Java | Enterprise, permissioned chains | Hyperledger ecosystem |
| **Reth** | Rust | Performance, modularity | Emerging (2023+) |

### Client Profiles

**Geth (go-ethereum)**: The original Ethereum client, maintained by the Ethereum Foundation. Its codebase serves as the de facto specification when the Yellow Paper is ambiguous. Geth pioneered many optimizations including the "snap sync" protocol.

**Erigon**: Fork of Geth optimized for archive node operation. Uses a flat database structure instead of Merkle Patricia tries for historical data, dramatically reducing disk usage (from 12TB+ to ~2TB for full archive).

**Nethermind**: Written in C# for the .NET ecosystem. Popular among enterprises and provides excellent documentation. Powers many infrastructure providers.

**Besu**: Java-based client from Hyperledger, designed for enterprise use. Supports both public Ethereum and private permissioned networks. Includes built-in monitoring and enterprise features.

**Reth**: Modern Rust implementation focused on performance and modularity. Designed from the ground up with modern Rust practices. Gained significant traction in 2023-2024 for its speed and developer experience.

<Warning>
**Client Diversity Matters**: In 2021, a bug in Geth affected over 75% of the network. While the issue was quickly patched, it highlighted the danger of client monoculture. The Ethereum community actively encourages running minority clients to improve network resilience.
</Warning>

### Ethereum Classic Clients

ETC maintains its own client implementations:

| Client | Base | Notes |
|--------|------|-------|
| **Core-Geth** | Geth fork | Primary ETC client, maintained by ETC Cooperative |
| **Hyperledger Besu** | Native ETC | Enterprise-grade, multi-network support |

## Why EVM Became Dominant

Despite technical limitations (stack-based architecture, 256-bit words that are expensive on modern hardware), the EVM became the dominant smart contract platform. Understanding why helps contextualize its design decisions.

### Network Effects

```
Developer Tooling → More Developers → More dApps → More Users → More Value
        ↑                                                          │
        └──────────────────────────────────────────────────────────┘
```

1. **First Mover**: Ethereum launched with working smart contracts in 2015, years before competitors
2. **Solidity**: Purpose-built language with familiar C-like syntax lowered the learning curve
3. **Tooling Ecosystem**: Truffle (2015), Hardhat (2019), Foundry (2021) created developer-friendly workflows
4. **ERC Standards**: Token standards (ERC-20, ERC-721) enabled composability and interoperability

### EVM Compatibility as Standard

Rather than competing with the EVM, most chains now embrace it:

| Chain Type | Examples | Approach |
|------------|----------|----------|
| **L1 EVM Forks** | BSC, Polygon, Avalanche C-Chain | Native EVM with different consensus |
| **L2 Rollups** | Optimism, Arbitrum, Base | EVM on Ethereum security |
| **zkEVM** | zkSync Era, Polygon zkEVM, Scroll | ZK proofs for EVM execution |

<Note>
**The EVM Standard**: When chains advertise "EVM compatibility," they mean contracts compiled for Ethereum work without modification. This has made the EVM a de facto standard, with more EVM-compatible chains than any alternative VM.
</Note>

### Alternative VMs

Some projects chose different virtual machine designs:

| VM | Chains | Trade-offs |
|----|--------|------------|
| **SVM (Solana)** | Solana, Eclipse | Parallel execution, different programming model |
| **Move VM** | Aptos, Sui | Resource-oriented, formal verification focus |
| **WASM** | Polkadot, Near, Cosmos | Standard bytecode, multiple source languages |
| **Cairo VM** | StarkNet | ZK-native, different paradigm |

Each has technical merits, but the EVM's network effects and tooling ecosystem remain dominant.

## Bitcoin Programmability Renaissance (2023+)

Interestingly, Bitcoin is now exploring expanded programmability through several approaches:

| Project | Mechanism | Status |
|---------|-----------|--------|
| **BitVM** | Fraud proofs for general computation | Active development |
| **OP_CAT** | Script concatenation (BIP revival) | Under debate |
| **Citrea** | Bitcoin validity rollup with ZK proofs | 2024 launch |
| **Stacks** | Clarity language, Bitcoin L2 | Operational |

These developments suggest the programmability debate has come full circle—Bitcoin is now implementing concepts Ethereum pioneered, while Ethereum's L2 ecosystem grows more Bitcoin-like in its security assumptions.

## Common Misattributions

### "Ethereum Invented Smart Contracts"

**Reality**: Nick Szabo conceptualized smart contracts in 1994, and Bitcoin included limited scripting from genesis (2009). Ethereum's innovation was the **Turing-complete VM on a blockchain**, not the concept of smart contracts itself.

**Confidence**: HIGH

### "The EVM is Well-Designed"

**Reality**: The EVM was designed quickly under constraints. Its 256-bit word size (optimized for cryptographic operations) is inefficient for general computation. The stack-based architecture limits optimization opportunities. These are known trade-offs, not necessarily optimal design choices.

**Confidence**: HIGH

### "Alternative VMs are Superior"

**Reality**: Technically, some alternative VMs (Move, WASM) have better properties for certain use cases. However, network effects, tooling, and developer familiarity make "superiority" context-dependent. The "best" VM depends on what you're optimizing for.

**Confidence**: HIGH

## Conclusions

Understanding the EVM at the bytecode level helps you:

- Write more gas-efficient contracts
- Debug complex issues
- Understand security vulnerabilities
- Optimize critical paths

Key takeaways:
- The EVM is stack-based with 256-bit words
- Storage is expensive, memory is cheap, stack is free
- Function calls are dispatched by selector matching
- Gas costs vary dramatically by operation
- Use inline assembly sparingly and carefully

---

## Research & Citations

This chapter draws on primary sources and research:

- [@szabo_smart_contracts_1996] — Nick Szabo's foundational smart contracts paper
- [@buterin_ethereum_2014] — Ethereum whitepaper introducing the EVM concept
- [@wood_ethereum_yellow_2014] — Gavin Wood's formal EVM specification
- [@eip_1559_2019] — EIP-1559 base fee mechanism
- [@eip_2929_2020] — Access list gas cost changes
- [@eip_1153_2022] — Transient storage specification
- [@eip_5656_2022] — MCOPY opcode specification

For deeper exploration of EVM mechanics, see the Yellow Paper's formal state transition function and the EIP repository for opcode specifications.
