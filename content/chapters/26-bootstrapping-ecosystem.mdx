---
title: Bootstrapping an EVM Ecosystem
description: The dependency tree for building DeFi infrastructure from scratch
chapter: 26
---

# Bootstrapping an EVM Ecosystem

> "Decentralization flows down, never up. A centralized foundation guarantees centralized outcomes."
>
> — C. M. Mercer

This quote opened Chapter 1, and we return to it now with deeper understanding. You've learned each DeFi primitive individually—tokens, AMMs, lending, oracles, governance. This chapter reveals how they fit together: the dependency tree that determines what must exist before something else can work.

If you're building on a new EVM chain, launching an L2, or trying to understand why some ecosystems thrive while others stagnate, this chapter provides the map.

## The Dependency Tree

Every application in an EVM ecosystem depends on lower-level primitives. This isn't just conceptual—it's functional. You literally cannot deploy certain contracts without others existing first.

```
                    ┌─────────────────────────────────────┐
                    │         USER APPLICATIONS           │
                    │   (Wallets, Dashboards, Analytics)  │
                    └─────────────────┬───────────────────┘
                                      │
        ┌─────────────────────────────┼─────────────────────────────┐
        │                             │                             │
        ▼                             ▼                             ▼
┌───────────────┐           ┌─────────────────┐           ┌─────────────────┐
│  LAUNCHPADS   │           │   PREDICTION    │           │   GOVERNANCE    │
│  (Pump.fun)   │           │    MARKETS      │           │     (DAOs)      │
└───────┬───────┘           │  (Polymarket)   │           └────────┬────────┘
        │                   └────────┬────────┘                    │
        │                            │                             │
        └────────────┬───────────────┼─────────────────────────────┘
                     │               │
                     ▼               ▼
              ┌──────────────────────────────┐
              │         DEX / AMMs           │
              │  (Uniswap, Curve, Aerodrome) │
              └──────────────┬───────────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
              ▼              ▼              ▼
       ┌───────────┐  ┌───────────┐  ┌───────────┐
       │  LENDING  │  │ STABLES   │  │  ORACLES  │
       │(Aave,Comp)│  │(DAI,USDC) │  │(Chainlink)│
       └─────┬─────┘  └─────┬─────┘  └─────┬─────┘
             │              │              │
             └──────────────┼──────────────┘
                            │
                            ▼
              ┌──────────────────────────────┐
              │       TOKEN STANDARDS        │
              │   (ERC-20, ERC-721, ERC-1155)│
              └──────────────┬───────────────┘
                             │
                             ▼
              ┌──────────────────────────────┐
              │         EVM CHAIN            │
              │   (Execution + Consensus)    │
              └──────────────────────────────┘
```

![DeFi Dependency Tree](/images/diagrams/ch26-dependency-tree.svg)

## Bootstrap Order for a New Chain

If you have an empty EVM chain and want to build a functional DeFi ecosystem, here's the order of operations:

### Phase 1: Foundation (Week 1-2)

**1. Wrapped Native Token**

Every ecosystem needs a wrapped version of the native token (like WETH) because the native token doesn't follow ERC-20:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract WETH is ERC20 {
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    constructor() ERC20("Wrapped Ether", "WETH") {}

    receive() external payable {
        deposit();
    }

    function deposit() public payable {
        _mint(msg.sender, msg.value);
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf(msg.sender) >= wad);
        _burn(msg.sender, wad);
        payable(msg.sender).transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }
}
```

**Canonical address:** Deploy WETH at a memorable CREATE2 address so every protocol knows where to find it.

**2. Token Factory**

Standard token deployment for projects:

```solidity
contract TokenFactory {
    event TokenCreated(address indexed token, string name, string symbol, address creator);

    function createToken(
        string memory name,
        string memory symbol,
        uint256 initialSupply
    ) external returns (address) {
        ERC20Token token = new ERC20Token(name, symbol, initialSupply, msg.sender);
        emit TokenCreated(address(token), name, symbol, msg.sender);
        return address(token);
    }
}
```

**3. Multicall Contract**

Enables batching read calls (essential for frontends):

```solidity
contract Multicall3 {
    struct Call3 {
        address target;
        bool allowFailure;
        bytes callData;
    }

    struct Result {
        bool success;
        bytes returnData;
    }

    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory results) {
        results = new Result[](calls.length);
        for (uint256 i = 0; i < calls.length; i++) {
            (bool success, bytes memory returnData) = calls[i].target.call(calls[i].callData);
            if (!calls[i].allowFailure) require(success);
            results[i] = Result(success, returnData);
        }
    }
}
```

### Phase 2: DEX (Week 2-4)

**4. Basic AMM (Uniswap V2 Style)**

The first DEX should be simple and battle-tested:

```solidity
// Uniswap V2 core
- Factory: Creates pairs
- Pair: Holds liquidity, executes swaps
- Router: User-friendly interface

// Why V2 first (not V3)?
// - Simpler to deploy and audit
// - Sufficient for bootstrapping
// - V3 can come later for capital efficiency
```

**Deploy order:**
1. Factory contract
2. Router contract (references factory + WETH)
3. Create WETH/USDC pair (or WETH/USDT)
4. Seed initial liquidity

**5. DEX Aggregator / Router**

Even with one DEX, deploy aggregator infrastructure for future compatibility:

```solidity
interface ISwapRouter {
    function swap(
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut,
        address recipient
    ) external returns (uint256 amountOut);
}

contract SwapAggregator {
    mapping(address => bool) public approvedRouters;

    function swap(
        address router,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut
    ) external returns (uint256) {
        require(approvedRouters[router], "Router not approved");

        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        IERC20(tokenIn).approve(router, amountIn);

        return ISwapRouter(router).swap(
            tokenIn,
            tokenOut,
            amountIn,
            minAmountOut,
            msg.sender
        );
    }
}
```

### Phase 3: Price Infrastructure (Week 4-6)

**6. Oracle Integration**

You have several options depending on chain support:

| Option | When to Use |
|--------|-------------|
| **Chainlink** | If available on your chain (most L2s) |
| **Uniswap TWAP** | If you have sufficient DEX liquidity |
| **RedStone/Pyth** | For newer chains or specialized needs |
| **Custom oracle** | Last resort, introduces centralization |

```solidity
// TWAP Oracle from your DEX
contract TWAPOracle {
    IUniswapV2Pair public pair;
    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint32 public blockTimestampLast;
    uint256 public price0Average;
    uint256 public price1Average;

    uint256 public constant PERIOD = 1 hours;

    function update() external {
        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) =
            UniswapV2OracleLibrary.currentCumulativePrices(address(pair));

        uint32 timeElapsed = blockTimestamp - blockTimestampLast;

        if (timeElapsed >= PERIOD) {
            price0Average = (price0Cumulative - price0CumulativeLast) / timeElapsed;
            price1Average = (price1Cumulative - price1CumulativeLast) / timeElapsed;

            price0CumulativeLast = price0Cumulative;
            price1CumulativeLast = price1Cumulative;
            blockTimestampLast = blockTimestamp;
        }
    }
}
```

### Phase 4: Stablecoin Access (Week 6-8)

**7. Bridge Integration or Native Stablecoin**

Options for stablecoin liquidity:

**A. Bridge canonical stablecoins:**
- USDC via Circle's CCTP (if supported)
- USDT via official bridges
- Requires bridge contracts and liquidity

**B. Deploy CDP stablecoin:**
- Use native assets as collateral
- More complex but self-sovereign

**C. Wrapped stablecoins via bridge:**
- Deploy bridge accepting external stablecoins
- Issue wrapped versions on your chain

```solidity
// Simple bridge receiver for stablecoins
contract StablecoinBridge {
    IERC20 public wrappedUSDC;
    address public bridgeOperator;

    mapping(bytes32 => bool) public processedDeposits;

    function mint(
        address recipient,
        uint256 amount,
        bytes32 sourceChainTxHash,
        bytes calldata proof
    ) external {
        require(msg.sender == bridgeOperator);
        require(!processedDeposits[sourceChainTxHash]);

        processedDeposits[sourceChainTxHash] = true;
        wrappedUSDC.mint(recipient, amount);
    }
}
```

### Phase 5: Lending (Week 8-12)

**8. Lending Protocol**

With DEX, oracles, and stablecoins in place, lending becomes viable:

**Dependencies required:**
- Price oracles for collateral valuation
- DEX for liquidation execution
- Stablecoins for borrowing

**Deploy order:**
1. Interest rate model contracts
2. Core lending pool
3. Asset configurations (collateral factors, liquidation thresholds)
4. Liquidation bot infrastructure

```solidity
// Lending protocol initialization
contract LendingPool {
    struct AssetConfig {
        address oracle;
        uint256 collateralFactor;  // e.g., 75% = 7500
        uint256 liquidationThreshold; // e.g., 80% = 8000
        uint256 liquidationBonus;  // e.g., 5% = 500
        bool isActive;
    }

    mapping(address => AssetConfig) public assetConfigs;

    function initializeAsset(
        address asset,
        address oracle,
        uint256 collateralFactor,
        uint256 liquidationThreshold,
        uint256 liquidationBonus
    ) external onlyAdmin {
        assetConfigs[asset] = AssetConfig({
            oracle: oracle,
            collateralFactor: collateralFactor,
            liquidationThreshold: liquidationThreshold,
            liquidationBonus: liquidationBonus,
            isActive: true
        });
    }
}
```

### Phase 6: Governance (Week 12-16)

**9. Governance Infrastructure**

Once the protocol has users and value, add governance:

```solidity
// OpenZeppelin Governor setup
contract EcosystemGovernor is
    Governor,
    GovernorSettings,
    GovernorCountingSimple,
    GovernorVotes,
    GovernorVotesQuorumFraction,
    GovernorTimelockControl
{
    constructor(
        IVotes _token,
        TimelockController _timelock
    )
        Governor("Ecosystem Governor")
        GovernorSettings(
            1 days,      // voting delay
            1 weeks,     // voting period
            100_000e18   // proposal threshold
        )
        GovernorVotes(_token)
        GovernorVotesQuorumFraction(4) // 4% quorum
        GovernorTimelockControl(_timelock)
    {}
}
```

### Phase 7: Advanced Applications (Week 16+)

With the foundation in place, advanced applications become possible:

**10. Prediction Markets**
- Requires: Oracles for resolution, stablecoins for betting, governance for disputes

**11. NFT Marketplaces**
- Requires: ERC-721/1155 support, payment infrastructure (WETH, stablecoins)

**12. Launchpads**
- Requires: DEX for price discovery, possibly lending for leverage

**13. Derivatives**
- Requires: Robust oracles, deep liquidity, stablecoins

## The Composability Ceiling

Each layer sets the ceiling for what's possible above it:

```
┌─────────────────────────────────────────────────────────────┐
│                    COMPOSABILITY CEILING                     │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Layer             │ Ceiling Set By                         │
│  ──────────────────┼───────────────────────────────────     │
│  Applications      │ DEX liquidity, oracle accuracy         │
│  DEX               │ Token availability, stablecoin depth   │
│  Lending           │ Oracle reliability, liquidation speed  │
│  Oracles           │ Data freshness, manipulation resistance│
│  Tokens            │ ERC-20 compatibility, bridge security  │
│  Chain             │ Finality, throughput, decentralization │
│                                                              │
│  A weak link at ANY level constrains EVERYTHING above it    │
└─────────────────────────────────────────────────────────────┘
```

### Case Study: Why Some L2s Struggle

New L2s often launch with:
- ✅ Working EVM execution
- ✅ Basic token support
- ❌ No oracle support (Chainlink doesn't cover them yet)
- ❌ No native stablecoin liquidity
- ❌ Unproven bridges

Result: Developers can deploy contracts, but can't build functional DeFi because the foundation is incomplete.

### Case Study: Why Ethereum Classic's DeFi is Limited

Despite being the original EVM chain:
- Limited oracle coverage (improving with Chainlink expansion)
- Lower stablecoin bridge liquidity
- Fewer active developers maintaining protocols

The chain works perfectly; the ecosystem dependencies are the constraint.

## Liquidity Bootstrap Strategies

Having contracts deployed isn't enough—you need liquidity.

### Strategy 1: Incentivized Liquidity Mining

Classic approach: pay LPs with native tokens

```solidity
contract LiquidityMining {
    IERC20 public rewardToken;
    IERC20 public lpToken;

    uint256 public rewardPerSecond;
    uint256 public accRewardPerShare;
    uint256 public lastRewardTime;

    mapping(address => uint256) public userStaked;
    mapping(address => uint256) public userRewardDebt;

    function deposit(uint256 amount) external {
        updatePool();

        if (userStaked[msg.sender] > 0) {
            uint256 pending = userStaked[msg.sender] * accRewardPerShare / 1e12 - userRewardDebt[msg.sender];
            if (pending > 0) {
                rewardToken.transfer(msg.sender, pending);
            }
        }

        lpToken.transferFrom(msg.sender, address(this), amount);
        userStaked[msg.sender] += amount;
        userRewardDebt[msg.sender] = userStaked[msg.sender] * accRewardPerShare / 1e12;
    }
}
```

**Pros:** Quick liquidity bootstrap
**Cons:** Mercenary liquidity leaves when rewards end

### Strategy 2: Protocol-Owned Liquidity (POL)

Use protocol treasury to own liquidity permanently:

```solidity
contract ProtocolOwnedLiquidity {
    IUniswapV2Router public router;
    address public pair;

    // Protocol sells tokens for LP positions it keeps
    function bondForLP(uint256 tokenAmount) external {
        // User provides tokens
        token.transferFrom(msg.sender, address(this), tokenAmount);

        // Protocol adds to LP (from treasury)
        uint256 ethAmount = treasury.allocateETH(tokenAmount);

        router.addLiquidityETH{value: ethAmount}(
            address(token),
            tokenAmount,
            0, 0,
            address(this), // Protocol keeps LP
            block.timestamp
        );

        // User gets discounted tokens or bonds
        bonds[msg.sender] += calculateBondValue(tokenAmount);
    }
}
```

**Pros:** Permanent liquidity, protocol captures LP fees
**Cons:** Requires treasury, complex tokenomics

### Strategy 3: Concentrated Liquidity Incentives

For Uniswap V3-style DEXs, incentivize specific ranges:

```solidity
contract ConcentratedLiquidityIncentives {
    IUniswapV3Pool public pool;

    // Only reward LPs in the active range
    function claimRewards(uint256 tokenId) external {
        (,, address token0, address token1, uint24 fee, int24 tickLower, int24 tickUpper,
         uint128 liquidity,,,,) = nftManager.positions(tokenId);

        // Check position is in active range
        (, int24 currentTick,,,,,) = pool.slot0();
        require(tickLower <= currentTick && currentTick < tickUpper, "Out of range");

        // Calculate and distribute rewards
        uint256 reward = calculateReward(liquidity, tickLower, tickUpper);
        rewardToken.transfer(msg.sender, reward);
    }
}
```

## Cross-Chain Considerations

Your EVM chain doesn't exist in isolation. Consider:

### Bridge Security

The bridge is often the weakest link:

```
┌─────────────────────────────────────────────────────────────┐
│                    BRIDGE RISK HIERARCHY                     │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Risk Level  │ Bridge Type                                  │
│  ────────────┼────────────────────────────────────────────  │
│  Lowest      │ Native rollup bridges (fraud/validity proofs)│
│  Low         │ Canonical bridges (protocol-run, audited)    │
│  Medium      │ Third-party bridges (Lock + mint, multisig)  │
│  High        │ Newer bridges (less battle-tested)           │
│  Highest     │ Centralized bridges (single operator)        │
│                                                              │
│  Ecosystem value is limited by bridge trust assumptions     │
└─────────────────────────────────────────────────────────────┘
```

### Canonical vs Bridged Assets

| Asset Type | Properties | Example |
|------------|------------|---------|
| Native | Born on this chain | Native governance token |
| Canonical bridged | Official bridge, trusted | USDC via CCTP |
| Third-party bridged | Various bridges exist | wBTC via various bridges |
| Wrapped | Represents locked asset | WETH |

Standardize on canonical assets where possible to avoid fragmentation.

## Ecosystem Health Metrics

Track these to measure ecosystem maturity:

```solidity
// Ecosystem health dashboard queries

// 1. Total Value Locked
function getTVL() external view returns (uint256) {
    uint256 tvl;
    for (uint i = 0; i < protocols.length; i++) {
        tvl += protocols[i].getTVL();
    }
    return tvl;
}

// 2. DEX Volume (24h)
function getDailyVolume() external view returns (uint256);

// 3. Unique Active Addresses (24h)
function getActiveUsers() external view returns (uint256);

// 4. Oracle Freshness
function getOracleHealth() external view returns (
    uint256 averageUpdateFrequency,
    uint256 maxStaleness
);

// 5. Bridge Utilization
function getBridgeMetrics() external view returns (
    uint256 totalBridgedValue,
    uint256 dailyBridgeVolume
);
```

### Healthy Ecosystem Benchmarks

| Metric | Early Stage | Growing | Mature |
|--------|-------------|---------|--------|
| TVL | <$10M | $10M-$100M | >$100M |
| Daily DEX Volume | <$1M | $1M-$10M | >$10M |
| Active Addresses | <1K | 1K-10K | >10K |
| Oracle Coverage | 1-5 feeds | 10-20 feeds | 50+ feeds |
| Protocols | <10 | 10-50 | >50 |

## Contributing to the Greater EVM Landscape

Your chain doesn't have to compete—it can complement the broader ecosystem.

### Specialization Strategies

| Strategy | Example | Benefit |
|----------|---------|---------|
| Low-cost execution | L2s like Base, Arbitrum | Ethereum overflow |
| Specific use case | Gaming chains | Optimized for NFTs/gaming |
| Regulatory arbitrage | Certain jurisdictions | Access to restricted markets |
| Technical differentiation | ETC's PoW security | Different trust assumptions |
| Community focus | Chain-specific communities | Loyal user base |

### Interoperability Patterns

Build for cross-chain from the start:

```solidity
// Cross-chain message interface
interface ICrossChainReceiver {
    function receiveMessage(
        uint256 sourceChainId,
        address sourceAddress,
        bytes calldata message
    ) external;
}

// Protocol that works across chains
contract CrossChainVault is ICrossChainReceiver {
    mapping(uint256 => address) public remoteVaults;

    function depositCrossChain(
        uint256 targetChainId,
        uint256 amount
    ) external {
        token.transferFrom(msg.sender, address(this), amount);

        // Send message to target chain
        messenger.sendMessage(
            targetChainId,
            remoteVaults[targetChainId],
            abi.encode(msg.sender, amount)
        );
    }

    function receiveMessage(
        uint256 sourceChainId,
        address sourceAddress,
        bytes calldata message
    ) external {
        require(msg.sender == address(messenger));
        require(sourceAddress == remoteVaults[sourceChainId]);

        (address user, uint256 amount) = abi.decode(message, (address, uint256));
        // Credit user on this chain
        balances[user] += amount;
    }
}
```

## Summary: The Bootstrap Checklist

```markdown
## EVM Ecosystem Bootstrap Checklist

### Phase 1: Foundation
- [ ] Wrapped native token (WETH equivalent)
- [ ] Token factory for standard ERC-20 creation
- [ ] Multicall contract for batched reads
- [ ] Block explorer operational

### Phase 2: DEX
- [ ] Basic AMM deployed (V2-style)
- [ ] Router contract
- [ ] Initial WETH/stablecoin pair
- [ ] Liquidity seeded ($100K+ minimum)

### Phase 3: Price Infrastructure
- [ ] Oracle solution chosen and deployed
- [ ] Key price feeds operational (native/USD, major pairs)
- [ ] TWAP oracles as backup

### Phase 4: Stablecoins
- [ ] Bridge or native stablecoin operational
- [ ] Sufficient liquidity ($1M+)
- [ ] Stablecoin/WETH pairs on DEX

### Phase 5: Lending
- [ ] Lending protocol deployed
- [ ] Assets configured with proper parameters
- [ ] Liquidation infrastructure operational

### Phase 6: Governance
- [ ] Governance token distributed
- [ ] Governor contract deployed
- [ ] Timelock operational
- [ ] First proposals executed

### Phase 7: Growth
- [ ] Additional DEXs for competition
- [ ] Aggregator routing
- [ ] NFT infrastructure
- [ ] Advanced applications (prediction markets, derivatives)
```

## Conclusion

Building an EVM ecosystem is like constructing a building: you can't install the roof before the walls, and you can't build walls without a foundation. The dependency tree isn't just a conceptual model—it's the practical reality of what contracts can and cannot do without supporting infrastructure.

Remember Mercer's principle: decentralization flows down, never up. Every centralized component in your foundation becomes a ceiling for everything built above it. Choose your foundations wisely.

The most successful ecosystems aren't those that move fastest, but those that build each layer solidly before moving to the next. The composability that makes DeFi powerful also makes it fragile—a weakness at any level cascades upward.

Your EVM chain, whether it's an L2, a fork, or an established network like Ethereum Classic, contributes to the greater EVM landscape. Build with that interconnection in mind, and you contribute not just to your ecosystem, but to the entire EVM world.

The next chapter explores agentic development—how AI assistants are changing the way we write and deploy smart contracts.
