---
title: Zero-Knowledge Applications
description: From privacy to scaling through cryptographic proofs
chapter: 24
---

# Zero-Knowledge Proofs

Zero-knowledge proofs (ZKPs) are cryptographic methods that allow one party (the prover) to convince another party (the verifier) that a statement is true, without revealing any information beyond the validity of the statement itself.

In the EVM ecosystem, ZKPs enable both **privacy** (hiding transaction details) and **scalability** (ZK rollups). Understanding ZK requires tracing its evolution from theoretical foundations through practical deployment.

## Historical Evolution

### Theoretical Foundations (1985-2000)

The field began with groundbreaking work by **Goldwasser, Micali, and Rackoff (1985)** — "The Knowledge Complexity of Interactive Proof Systems":

- Introduced the concept of zero-knowledge proofs
- Defined knowledge complexity formally
- Proved that ZK proofs exist for NP-complete problems
- Established the theoretical framework for all subsequent ZK research

<Callout type="note">
This paper won the Gödel Prize (1993) and ACM Turing Award (2012). The authors showed that powerful proofs could be achieved while revealing nothing beyond truth.
</Callout>

**Fiat and Shamir (1986)** transformed the field by showing how to convert interactive proofs to non-interactive:

- Replace verifier's random challenges with hash function outputs
- Enables NIZKs (Non-Interactive Zero-Knowledge) in the random oracle model
- The "Fiat-Shamir heuristic" is used in virtually all practical ZK systems today

### The Path to Practicality (2000-2016)

| Year | System | Innovation |
|------|--------|------------|
| 2000s | PCPs | Probabilistically checkable proofs — verify by reading few bits |
| 2012 | **Pinocchio** | First practical SNARK — made ZK usable |
| 2013 | libsnark | Open-source SNARK library; enabled experimentation |
| 2014 | Zerocash paper | ZK for cryptocurrency privacy |
| 2016 | **Groth16** | Most efficient pairing-based SNARK; still widely used |
| 2016 | **Zcash launch** | First ZK cryptocurrency deployment |

### Modern Systems (2017-Present)

| Year | System | Contribution |
|------|--------|--------------|
| 2017 | Bulletproofs | Range proofs without trusted setup |
| 2017 | EIP-196/197 | ZK precompiles on Ethereum |
| 2018 | STARKs | Transparent (no trusted setup), post-quantum |
| 2019 | PLONK | Universal trusted setup; major breakthrough |
| 2019 | Halo | Recursive proofs without trusted setup |
| 2022 | Nova | Folding schemes for incremental verification |
| 2023-24 | zkEVM race | Polygon, zkSync, Scroll, Linea compete for EVM equivalence |

## What is a Zero-Knowledge Proof?

A zero-knowledge proof must satisfy three properties:

1. **Completeness** — If the statement is true, an honest prover can convince an honest verifier
2. **Soundness** — If the statement is false, no cheating prover can convince the verifier
3. **Zero-knowledge** — The verifier learns nothing beyond the truth of the statement

### The Classic Example: The Cave

Imagine a cave with a ring-shaped tunnel and a magic door in the middle:

```
         Entrance
            |
            v
         ┌──────┐
         │      │
     A ──┤      ├── B
         │      │
         └──┬───┘
            │
         Magic Door
         (needs password)
```

Alice wants to prove to Bob she knows the password without revealing it:

1. Bob waits outside
2. Alice enters and takes path A or B randomly
3. Bob enters and shouts "Come out via A" or "Come out via B"
4. If Alice knows the password, she can always exit the requested side

After many rounds, Bob becomes convinced Alice knows the password, but learned nothing about what it is.

## ZKP Systems

### zk-SNARKs

**S**uccinct **N**on-interactive **AR**guments of **K**nowledge

- **Succinct** — Small proof size, fast verification
- **Non-interactive** — No back-and-forth required
- **Arguments** — Computationally sound (not information-theoretically)
- **Knowledge** — Prover must know the witness

**Properties:**
- Proof size: ~200 bytes
- Verification time: ~10ms
- Requires trusted setup
- Used in: Zcash, zkSync Era, Aztec

### zk-STARKs

**S**calable **T**ransparent **AR**guments of **K**nowledge

- **Scalable** — Proof generation scales better with computation size
- **Transparent** — No trusted setup required

**Properties:**
- Proof size: ~100 KB
- Verification time: ~50ms
- No trusted setup (transparent)
- Used in: StarkNet, StarkEx

### Comparison

| Aspect | zk-SNARKs | zk-STARKs |
|--------|-----------|-----------|
| Proof size | ~200 B | ~100 KB |
| Verification time | Fast | Slower |
| Trusted setup | Required | Not needed |
| Quantum resistant | No | Yes |
| Prover time | Slower | Faster for large circuits |

### Bulletproofs

**Bünz, Bootle, Boneh et al. (2017)** introduced Bulletproofs for range proofs without trusted setup:

| Property | Value |
|----------|-------|
| Proof size | O(log n) — ~700 bytes for 64-bit range |
| Verification | O(n) — slower than SNARKs |
| Setup | None required |
| Primary use | Range proofs in Monero |

Bulletproofs trade verification speed for no trusted setup. They're ideal for proving values are within ranges (e.g., transaction amounts are positive) but not efficient enough for complex on-chain verification.

### SNARK Variants

| System | Setup | Proof Size | Best For |
|--------|-------|------------|----------|
| Groth16 | Circuit-specific | ~200 B | Fixed circuits (cheapest on-chain) |
| PLONK | Universal | ~400 B | Reusable setup, flexible circuits |
| Marlin | Universal | ~500 B | Academic research |
| Halo2 | None | ~5 KB | Recursive proofs |

### Recursive Proofs and Folding Schemes

**Recursive SNARKs** allow proofs to verify other proofs, enabling powerful compositions:

| System | Year | Innovation |
|--------|------|------------|
| **Halo** | 2019 | Recursive proofs without trusted setup |
| **Halo2** | 2021 | Improved efficiency; used by Zcash, Scroll |
| **Nova** | 2022 | Folding scheme for incremental verification |
| **HyperNova** | 2023 | Generalized folding for R1CS |
| **Protostar** | 2023 | Non-uniform IVC |

<Callout type="info">
**Folding schemes** compress multiple proof instances into one without fully verifying each. This is more efficient than recursive verification for many use cases — the key insight behind Nova and HyperNova.
</Callout>

**Applications of recursive proofs:**
- Prove arbitrarily long computations
- Aggregate many proofs into one
- Enable efficient zkVMs
- Power Mina Protocol's constant-size blockchain

## How ZK Proofs Work (Simplified)

### Arithmetic Circuits

Computations are converted to arithmetic circuits:

```
// Prove: I know x such that x * x = 9
// Without revealing x = 3

x ──┬──►[×]──► 9
    │    ▲
    └────┘
```

### R1CS (Rank-1 Constraint System)

Circuits are converted to constraints:

```
// For x² = y
// Constraint: x * x - y = 0

A · B = C
where:
  A = [x]
  B = [x]
  C = [y]
```

### The Proving Process

1. Write computation as circuit
2. Convert to polynomial equations
3. Commit to polynomial
4. Generate proof using randomness
5. Verifier checks proof

![Zero-Knowledge Proof Flow](/images/diagrams/ch24-zk-proof-flow.svg)

## ZK in Ethereum

### ZK Rollups

ZK rollups use validity proofs instead of fraud proofs:

```solidity
// Simplified ZK rollup verification
interface IZKVerifier {
    function verify(
        uint256[] calldata proof,
        uint256[] calldata publicInputs
    ) external view returns (bool);
}

contract ZKRollup {
    IZKVerifier public verifier;
    bytes32 public stateRoot;

    function submitBatch(
        bytes32 newStateRoot,
        uint256[] calldata proof,
        uint256[] calldata publicInputs
    ) external {
        // Public inputs include old and new state roots
        require(publicInputs[0] == uint256(stateRoot), "Invalid old state");
        require(publicInputs[1] == uint256(newStateRoot), "State mismatch");

        // Verify the ZK proof
        require(verifier.verify(proof, publicInputs), "Invalid proof");

        // Update state immediately (no challenge period!)
        stateRoot = newStateRoot;
    }
}
```

### zkEVM Taxonomy

Not all zkEVMs are equal. Vitalik Buterin proposed a taxonomy based on EVM equivalence:

| Type | Description | Trade-off | Examples |
|------|-------------|-----------|----------|
| **Type 1** | Fully Ethereum-equivalent | Slowest proving, full compatibility | Taiko |
| **Type 2** | EVM-equivalent | Minor differences (gas, precompiles) | Scroll, Polygon zkEVM |
| **Type 2.5** | EVM-equivalent except gas costs | Faster proving | — |
| **Type 3** | Almost EVM-equivalent | Some opcodes differ | Linea (transitional) |
| **Type 4** | High-level language compatible | Compiles Solidity to ZK-friendly VM | zkSync Era, StarkNet |

<Note>
**Type 1** is the holy grail — existing Ethereum tools work unchanged. But proving Ethereum's design choices (like Keccak256 hashing) is expensive. **Type 4** systems like zkSync compile Solidity to a ZK-optimized instruction set, making proving faster but requiring recompilation.
</Note>

### ZK Rollup Economics

Understanding the cost structure of ZK rollups:

| Component | Cost Factor | Who Pays |
|-----------|-------------|----------|
| **Proving** | ~$0.01-0.10 per tx | Sequencer (hardware, electricity) |
| **L1 Verification** | 200,000-500,000 gas | Sequencer |
| **Data availability** | ~16 gas/byte (calldata) or ~1 gas/byte (blobs) | Users (amortized) |

**Cost evolution with EIP-4844:**

| Rollup Type | Pre-4844 Cost/tx | Post-4844 Cost/tx |
|-------------|------------------|-------------------|
| Optimistic | ~$0.10 | ~$0.01 |
| ZK | ~$0.20 | ~$0.02 |

<Tip>
ZK rollups have higher fixed costs (proving) but lower marginal costs at scale. As batches grow larger, the per-transaction cost approaches the data availability cost alone.
</Tip>

### Privacy Protocols

ZKPs enable private transactions:

**Tornado Cash pattern:**
1. Deposit: Add commitment to Merkle tree
2. Withdraw: Prove membership without revealing which commitment

```solidity
// Simplified Tornado Cash-like mixer
contract Mixer {
    mapping(bytes32 => bool) public commitments;
    mapping(bytes32 => bool) public nullifiers;

    function deposit(bytes32 commitment) external payable {
        require(msg.value == 1 ether);
        commitments[commitment] = true;
    }

    function withdraw(
        bytes32 nullifier,
        bytes32 root,
        uint256[] calldata proof
    ) external {
        require(!nullifiers[nullifier], "Already withdrawn");
        require(verifyMerkleRoot(root), "Invalid root");

        // Verify ZK proof that prover:
        // 1. Knows a commitment in the tree
        // 2. Correctly derived the nullifier
        require(verifier.verify(proof, [nullifier, root]), "Invalid proof");

        nullifiers[nullifier] = true;
        payable(msg.sender).transfer(1 ether);
    }
}
```

### Privacy Pools and Compliant Privacy

After Tornado Cash sanctions (August 2022), research shifted toward "compliant privacy" — proving funds aren't from illicit sources without revealing the full transaction graph.

**Privacy Pools** (Buterin et al., 2023) propose:

```
1. Users deposit to shielded pool (like Tornado Cash)
2. Association sets define "acceptable" deposit sources
3. Withdrawal proves membership in acceptable set
4. Regulators can verify compliance without seeing full history
```

```solidity
// Privacy Pool withdrawal (simplified)
function withdraw(
    bytes32 nullifier,
    bytes32 root,
    bytes32 associationSetRoot,  // New: acceptable sources
    uint256[] calldata proof
) external {
    // Prove:
    // 1. You know a valid deposit commitment
    // 2. Your deposit is in the association set
    // 3. You haven't withdrawn before (nullifier)
    require(verifier.verify(proof, [nullifier, root, associationSetRoot]));
    // ... transfer funds
}
```

This approach aims to preserve privacy benefits while addressing regulatory concerns — users can prove their funds are "clean" without revealing their exact source.

### Identity & Credentials

Prove attributes without revealing full identity:

```solidity
// Age verification without revealing birth date
interface IAgeVerifier {
    function verifyOver18(
        uint256[] calldata proof,
        bytes32 identityCommitment
    ) external view returns (bool);
}

contract AgeGatedContract {
    IAgeVerifier public verifier;

    function accessAdultContent(uint256[] calldata proof) external view {
        // Prove you're over 18 without revealing your actual age
        require(
            verifier.verifyOver18(proof, userCommitment),
            "Must be over 18"
        );
        // Allow access
    }
}
```

## Writing ZK Circuits

### Circom

Circom is a domain-specific language for ZK circuits:

```circom
pragma circom 2.0.0;

// Prove knowledge of factors
template Factorize() {
    signal input a;     // Private: factor 1
    signal input b;     // Private: factor 2
    signal output c;    // Public: product

    c <== a * b;

    // Constraint: neither factor is 1
    signal a_minus_1;
    signal b_minus_1;
    a_minus_1 <== a - 1;
    b_minus_1 <== b - 1;

    // Both must be non-zero
    signal a_check;
    signal b_check;
    a_check <== a_minus_1 * a_minus_1;
    b_check <== b_minus_1 * b_minus_1;
}

component main {public [c]} = Factorize();
```

### Noir

Noir is a Rust-like language for ZK circuits:

```rust
// Noir example: prove knowledge of hash preimage
fn main(x: Field, hash: pub Field) {
    let computed_hash = std::hash::pedersen([x]);
    assert(hash == computed_hash);
}
```

### Compile and Use

```bash
# Compile Circom circuit
circom circuit.circom --r1cs --wasm --sym

# Generate proving key (trusted setup)
snarkjs groth16 setup circuit.r1cs pot12_final.ptau circuit_final.zkey

# Generate proof
snarkjs groth16 prove circuit_final.zkey witness.wtns proof.json public.json

# Verify proof
snarkjs groth16 verify verification_key.json public.json proof.json
```

## On-Chain Verification

### Groth16 Verifier

```solidity
// Auto-generated verifier contract
contract Groth16Verifier {
    // Elliptic curve points (from trusted setup)
    uint256 constant IC0x = 0x...;
    uint256 constant IC0y = 0x...;

    function verify(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[1] memory input
    ) public view returns (bool) {
        // Pairing check
        // e(A, B) = e(α, β) · e(L, γ) · e(C, δ)
        return Pairing.pairingCheck(...);
    }
}
```

### Gas Costs

On-chain verification is expensive but constant:

| Operation | Gas Cost | Notes |
|-----------|----------|-------|
| BN256 addition (EIP-196) | 150 | Basic curve operation |
| BN256 scalar multiplication | 6,000 | Key operation for verification |
| BN256 pairing check (EIP-197) | 45,000 per pair | Core SNARK verification |
| Groth16 verification | ~200,000 | 3 pairings + additions |
| PLONK verification | ~300,000 | More operations, same curve |
| STARK verification | ~1,000,000+ | Hash-based, no pairings |

The cost is independent of circuit complexity — you pay the same whether proving 1 operation or 1 million.

### ZK Precompiles on Ethereum

Ethereum's EIP-196 and EIP-197 (Byzantium, 2017) enabled efficient on-chain SNARK verification:

```solidity
// EIP-196: BN256 curve addition
address constant BN256_ADD = address(0x06);
// EIP-196: BN256 scalar multiplication
address constant BN256_MUL = address(0x07);
// EIP-197: BN256 pairing check
address constant BN256_PAIRING = address(0x08);

// Verify Groth16 proof using pairing precompile
function verifyProof(
    uint256[2] memory a,
    uint256[2][2] memory b,
    uint256[2] memory c,
    uint256[] memory publicInputs
) public view returns (bool) {
    // Construct pairing input
    // e(A, B) = e(α, β) · e(L, γ) · e(C, δ)
    bytes memory input = abi.encodePacked(a, b, c, publicInputs);

    (bool success, bytes memory result) = BN256_PAIRING.staticcall(input);
    return success && abi.decode(result, (bool));
}
```

**Future precompiles under discussion:**
- BLS12-381 operations (better security margin, Ethereum 2.0 compatibility)
- KZG commitment verification (for data availability sampling)
- Poseidon hash (ZK-friendly, faster to prove than Keccak)

### Cross-Chain ZK Applications

ZK proofs enable trustless cross-chain communication:

| Application | How It Works | Example |
|-------------|--------------|---------|
| **ZK light clients** | Prove consensus without running full node | Succinct's Telepathy |
| **Storage proofs** | Prove historical state existed | Herodotus, Axiom |
| **Bridge verification** | Prove deposit on source chain | zkBridge |
| **Cross-rollup transfers** | Prove L2 state on another L2 | Polymer, Lagrange |

```
Traditional bridge: Trust relayers/validators
ZK bridge: Verify proof that event occurred on source chain
```

This shift from social trust to cryptographic verification is fundamental to blockchain scaling.

## ZK Development Stack

### Languages

| Language | Style | Ecosystem | Best For |
|----------|-------|-----------|----------|
| **Circom** | Domain-specific | snarkjs, SnarkJS | Most tutorials, Tornado Cash |
| **Noir** | Rust-like | Aztec | Developer experience, Aztec apps |
| **Cairo** | Python-like | StarkNet | StarkNet contracts |
| **Leo** | Rust-like | Aleo | Privacy-focused L1 |
| **o1js** | TypeScript | Mina | Browser-friendly proofs |

### Libraries

| Library | Language | Proof System | Used By |
|---------|----------|--------------|---------|
| **snarkjs** | JavaScript | Groth16, PLONK | Web apps, prototypes |
| **arkworks** | Rust | Multiple | Research, production |
| **gnark** | Go | Groth16, PLONK | Linea, enterprise |
| **halo2** | Rust | Halo2/KZG | Scroll, zkSync |
| **Plonky2** | Rust | PLONK + FRI | Polygon zkEVM |

### Services

| Service | Function | Use Case |
|---------|----------|----------|
| **Axiom** | Historical Ethereum data proofs | Prove past state without replay |
| **Herodotus** | Cross-chain state proofs | Trustless cross-L2 data |
| **Risc0** | ZK proofs for RISC-V programs | Prove arbitrary Rust code |
| **Succinct** | zkVM infrastructure | General-purpose proving |
| **Bonsai** | Risc0 proving service | Remote proof generation |

### Development Workflow

```bash
# Typical Circom + snarkjs workflow

# 1. Write circuit
cat > circuit.circom << 'EOF'
pragma circom 2.0.0;
template Multiplier() {
    signal input a;
    signal input b;
    signal output c;
    c <== a * b;
}
component main = Multiplier();
EOF

# 2. Compile to R1CS
circom circuit.circom --r1cs --wasm --sym -o build/

# 3. Trusted setup (Powers of Tau ceremony for production)
snarkjs powersoftau new bn128 12 pot12_0000.ptau
snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau
snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau
snarkjs groth16 setup build/circuit.r1cs pot12_final.ptau circuit_0000.zkey
snarkjs zkey contribute circuit_0000.zkey circuit_final.zkey

# 4. Export verification key
snarkjs zkey export verificationkey circuit_final.zkey verification_key.json

# 5. Generate proof (with witness)
snarkjs groth16 prove circuit_final.zkey witness.wtns proof.json public.json

# 6. Verify locally
snarkjs groth16 verify verification_key.json public.json proof.json

# 7. Generate Solidity verifier
snarkjs zkey export solidityverifier circuit_final.zkey Verifier.sol
```

<Tip>
For production, use a proper Powers of Tau ceremony (like Hermez's or Zcash's) rather than generating your own. Universal setups (PLONK) reduce this burden.
</Tip>

## Practical Considerations

### Trusted Setup

Many ZK systems require a trusted setup ceremony:

```
Setup parameters = τ (toxic waste)
If anyone learns τ, they can create fake proofs
```

Solutions:
- Multi-party computation (if one participant is honest, setup is secure)
- Universal setup (reusable for many circuits)
- Transparent setup (STARKs, no toxic waste)

### Prover Time

Generating proofs is computationally intensive:

| Circuit Size | Proof Time |
|--------------|------------|
| 2¹⁰ constraints | ~1 second |
| 2¹⁶ constraints | ~10 seconds |
| 2²⁰ constraints | ~2 minutes |
| 2²⁴ constraints | ~30 minutes |

**Hardware acceleration:**
- GPU proving (10-100x speedup)
- FPGA/ASIC proving
- Distributed proving

### Circuit Design

Efficient circuits are critical:

```circom
// Bad: Uses many constraints
template Bad() {
    signal input x;
    signal output y;
    y <== x * x * x * x;  // 3 multiplications = 3 constraints
}

// Good: Fewer constraints
template Good() {
    signal input x;
    signal output y;
    signal x2;
    x2 <== x * x;         // 1 constraint
    y <== x2 * x2;        // 1 constraint
                          // Total: 2 constraints
}
```

## Adoption Timeline

| Date | Event | Significance |
|------|-------|--------------|
| 1985 | GMR paper | ZKP theoretical foundation established |
| 1986 | Fiat-Shamir heuristic | Non-interactive transformation |
| 2012 | Pinocchio | First practical SNARK |
| 2014 | Zerocash paper | ZK for cryptocurrency privacy |
| **Oct 2016** | **Zcash launch** | First ZK cryptocurrency deployment |
| 2016 | Groth16 | Most efficient SNARK; still widely used |
| 2017 | EIP-196/197 | ZK precompiles on Ethereum |
| 2017 | Bulletproofs | Range proofs without trusted setup |
| 2018 | STARKs introduced | Transparent, post-quantum secure |
| 2019 | PLONK | Universal trusted setup breakthrough |
| 2019 | Tornado Cash | ZK privacy mixer on Ethereum |
| 2020 | Loopring, zkSync 1.0 | First ZK rollups live |
| 2022 | StarkNet mainnet | STARK-based general-purpose rollup |
| 2022 | Nova folding scheme | Efficient incremental verification |
| 2023 | zkSync Era | EVM-compatible ZK rollup |
| 2024 | Scroll, Linea mainnet | zkEVM competition intensifies |

## Common Misconceptions

<Warning>
**"ZK proofs are only for privacy"** — False. ZK proofs have two major applications: privacy (Zcash, Tornado Cash) and scalability (rollups). For rollups, ZK is about compression and verification, not hiding data.
</Warning>

**"Trusted setup means insecure"** — Multi-party computation ceremonies distribute trust. Zcash's "Powers of Tau" had thousands of participants. If *any* participant is honest, the setup is secure. Universal setups (PLONK) only need to be done once.

**"STARKs are always better"** — Trade-offs exist:
- SNARKs: ~200 bytes (cheap on-chain), no post-quantum security
- STARKs: ~50-100 KB (expensive on-chain), post-quantum secure
- Choice depends on use case

## Conclusions

Zero-knowledge proofs represent one of cryptography's most powerful ideas — proving knowledge without revealing it. From Goldwasser, Micali, and Rackoff's 1985 theoretical breakthrough to today's zkEVM rollups processing millions of transactions, ZK has evolved from academic curiosity to critical infrastructure.

**For Privacy:**
- Hide transaction amounts and participants
- Prove identity attributes without revealing data
- Enable confidential DeFi (though regulatory pressure is significant)

**For Scalability:**
- ZK rollups provide fast finality (no 7-day challenge period)
- Constant verification cost regardless of batch size
- Type 1-4 zkEVMs offer different compatibility/performance trade-offs

**Key Takeaways:**
- ZKPs prove statements without revealing underlying data
- The GMR → Fiat-Shamir → Groth16 → PLONK lineage shows how theory becomes practice
- zk-SNARKs are small but need trusted setup; zk-STARKs are transparent but larger
- Bulletproofs, Nova, and folding schemes expand the toolkit
- Circuit design is an art — efficiency determines cost
- zkEVM taxonomy (Type 1-4) explains the compatibility/speed trade-off

The ZK ecosystem continues to mature rapidly. As proving times decrease and tooling improves, ZK may become as invisible to developers as HTTPS encryption — essential infrastructure that "just works."
