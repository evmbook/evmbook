---
title: Layer 2 Solutions
description: Rollups, EIP-4844 blobs, and the L2 landscape evolution
chapter: 23
---

# Layer 2 Solutions

Blockchain scalability has been the defining challenge of the EVM ecosystem. The base layer of Ethereum processes 15-30 transactions per second. That's nowhere near enough for global adoption. Layer 2 solutions are how we scale—moving execution off-chain while inheriting security from L1.

This chapter traces the evolution of L2 scaling, from early failures through the rollup era to the blob-powered present.

## Historical Context

Layer 2 scaling wasn't a new idea when Ethereum launched. The concept evolved through multiple iterations.

### Academic Foundations

**Payment Channels** — The concept of off-chain transactions with on-chain settlement dates to **Bitcoin's early days (2012-2013)**. The Lightning Network whitepaper (2016) formalized bidirectional payment channels with hash time-locked contracts (HTLCs).

**Plasma** — Poon and Buterin's 2017 paper proposed nested child chains with Merkle commitments to L1. While Plasma itself failed, it identified the data availability problem that shaped all subsequent scaling research.

**Rollups** — The rollup concept emerged from Plasma's lessons. By posting all transaction data to L1, rollups solved data availability while keeping execution off-chain. Optimistic rollups (assume valid, prove fraud) and ZK rollups (prove validity cryptographically) emerged as the two main approaches.

### The Truebit Influence

**Truebit (2017)** proposed off-chain computation with on-chain verification games—the intellectual precursor to optimistic rollup fraud proofs. The verification game concept influenced Arbitrum's multi-round dispute resolution.

## The Scalability Problem

### The Trilemma

Blockchains face fundamental tradeoffs:

```
                    Decentralization
                          ▲
                         / \
                        /   \
                       /     \
                      /       \
                     /_________\
              Security ◀─────────▶ Scalability
```

- **Decentralization** — Many independent validators
- **Security** — Resistance to attacks
- **Scalability** — High transaction throughput

Traditional databases sacrifice decentralization for scalability. Early blockchains sacrificed scalability for decentralization. The challenge: improve throughput without compromising the other two.

### Why L2, Not L1 Scaling?

L1 scaling options have limits:

| Approach | Tradeoff |
|----------|----------|
| Bigger blocks | Higher hardware requirements → less decentralization |
| Faster blocks | More orphan blocks, weaker consensus |
| Sharding | Complex, years away from full implementation |

L2 solutions bypass these tradeoffs by moving execution off-chain while using L1 for security and data availability.

## L2 Evolution Timeline

### Era 0: The Early Attempts (2017-2019)

The first scaling proposals tried to move transactions off-chain with minimal L1 footprint.

#### State Channels

**The idea:** Lock funds on-chain, transact off-chain, settle final state.

```
1. Alice and Bob each lock 10 ETH on-chain
2. They exchange signed messages off-chain (Alice pays Bob 1 ETH, etc.)
3. Either party can close the channel with the latest signed state
4. Final balances settled on-chain
```

**Why it worked:**
- Unlimited transactions per second between participants
- Only two on-chain transactions (open and close)
- Bitcoin's Lightning Network proved the concept

**Why it struggled:**
- Requires both parties online
- Channel capacity limited by locked funds
- Hub-and-spoke networks have centralization pressure
- Complex for general-purpose computation (not just payments)

**Ethereum examples:** Raiden Network (launched 2020), Connext

#### Plasma

**The idea:** Child chains with cryptographic commitments to L1.

```
L1 commits:     Block 1 → Block 2 → Block 3 → ...
                   ↓         ↓         ↓
Plasma chain:   Subtree of transactions validated off-chain
```

**The 2017 vision:** Plasma chains would handle millions of transactions, posting only Merkle roots to Ethereum.

**Why it failed:**
1. **Data availability problem**: If operators withhold data, users can't prove their balances
2. **Mass exit scenarios**: If chain becomes invalid, everyone exits at once → L1 congestion
3. **Complexity**: Different Plasma variants (MVP, Cash, Debit) all had edge cases
4. **Limited functionality**: Hard to support general smart contracts

**Developer Lesson:** Plasma taught us that data availability is the critical bottleneck. You can't just post commitments—users need the actual data to verify and exit.

<Callout type="note">
Plasma research wasn't wasted. The data availability problem it exposed directly led to rollup designs and later to EIP-4844 blobs.
</Callout>

#### Sidechains: A Different Tradeoff

Sidechains run their own consensus but bridge to Ethereum. Unlike Plasma, they don't rely on Ethereum for security—just for asset transfers.

**Polygon PoS (2020-present)**

Polygon (originally Matic) launched as a Plasma-like solution but evolved into a proof-of-stake sidechain:

- **Own validator set**: ~100 validators staking MATIC
- **Checkpoint commitments**: Merkle roots posted to Ethereum
- **EVM-compatible**: Same tooling, easy migration
- **Cheap and fast**: Fraction of Ethereum fees, ~2 second blocks

```
Ethereum ←────────────────────────────→ Polygon PoS
         Bridge contracts              Own consensus
         Checkpoints every ~30 min     Own validators
         Final settlement              Own data availability
```

**The Sidechain Tradeoff:**

| Aspect | Rollups | Sidechains (Polygon PoS) |
|--------|---------|--------------------------|
| Security source | Ethereum | Own validators |
| Data availability | Posted to Ethereum | Own chain |
| Trust assumption | Ethereum consensus | Sidechain consensus |
| Cost | Higher (L1 data costs) | Lower (independent chain) |
| Censorship resistance | Inherits from Ethereum | Own validator set |

**Why Polygon Succeeded:**

1. **First mover**: Scaling solution available before rollups matured
2. **EVM equivalence**: No code changes needed for most dApps
3. **Business development**: Active ecosystem partnerships
4. **Cheap transactions**: Enabled use cases impossible on L1

**The Polygon Pivot:**

Polygon evolved from "sidechain" to "multi-chain ecosystem":
- **Polygon zkEVM**: Type 2 ZK rollup (true L2 security)
- **Polygon CDK**: Chain development kit for custom rollups
- **Polygon Miden**: zkSTARK-based rollup (in development)
- **AggLayer**: Unified bridge and liquidity across Polygon chains

<Callout type="info">
**Builder Perspective**: Polygon PoS remains useful for cost-sensitive applications where decentralization from Ethereum's validator set isn't critical. For higher security needs, rollups (including Polygon zkEVM) offer Ethereum-grade security.
</Callout>

### Era 1: Optimistic Rollups Emerge (2020-2021)

The insight: post all transaction data to L1, but execute off-chain. Anyone can verify; challenge if wrong.

#### The Rollup Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                        Layer 2 Rollup                        │
│  ┌────────┐  ┌────────┐  ┌────────┐                         │
│  │  Tx 1  │  │  Tx 2  │  │  Tx 3  │  ... (1000s of txs)    │
│  └────────┘  └────────┘  └────────┘                         │
│                    │                                         │
│                    ▼                                         │
│              ┌──────────────────┐                           │
│              │  Batch (Sequencer) │                          │
│              └────────┬─────────┘                           │
│                       │                                      │
└───────────────────────┼──────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│                     Layer 1 (Ethereum)                        │
│              ┌──────────────────────────┐                     │
│              │  State Root + Tx Data    │                     │
│              └──────────────────────────┘                     │
└───────────────────────────────────────────────────────────────┘
```

**Key difference from Plasma:** All transaction data is posted to L1. Anyone can reconstruct state from on-chain data alone.

#### Optimism Launch (2021)

Optimism pioneered optimistic rollups on mainnet:

- **OVM (Optimistic Virtual Machine)**: Interpreted EVM execution
- **7-day challenge period**: Time for fraud proofs
- **Single sequencer**: Initially centralized for performance

**Early challenges:**
- OVM wasn't fully EVM-equivalent (some contracts needed modification)
- High fees (still using calldata, pre-blobs)
- Centralized sequencer

#### Arbitrum Launch (2021)

Arbitrum took a different approach:

- **AVM (Arbitrum Virtual Machine)**: Different fraud proof mechanism
- **Multi-round dispute resolution**: More efficient fraud proofs
- **Earlier mainnet launch**: Beat Optimism to market

**Arbitrum's advantages:**
- Better EVM compatibility from the start
- More efficient fraud proofs (interactive proving)
- Larger ecosystem adoption

By late 2021:
- Arbitrum: ~$2B TVL
- Optimism: ~$500M TVL
- Both proving the rollup model worked

#### The OP Stack (2022)

Optimism open-sourced its rollup architecture as the "OP Stack":

```
OP Stack Components:
├── Execution: EVM-equivalent execution
├── Sequencing: Transaction ordering
├── Derivation: L1 data → L2 state
├── Settlement: Fraud proofs, withdrawals
└── Bridging: L1 ↔ L2 communication
```

This enabled:
- **Base (Coinbase)**: Launched 2023, became the highest-throughput EVM chain by late 2024—processing more transactions than Ethereum mainnet. Coinbase integration provided direct fiat onramp.
- **Mode**: DeFi-focused OP Stack chain
- **Zora**: NFT-focused OP Stack chain
- **World Chain**: Identity/Worldcoin's L2

**Developer Lesson:** Open-sourcing infrastructure creates ecosystems. The OP Stack's adoption proved that modular rollup architecture beats proprietary solutions.

### Era 2: ZK Rollup Maturity (2022-2024)

Zero-knowledge rollups use validity proofs instead of fraud proofs: prove execution was correct, don't assume and challenge.

#### The ZK Advantage

**Optimistic rollups:**
```
Submit batch → Wait 7 days → If no challenge → Finalized
```

**ZK rollups:**
```
Submit batch + proof → Verify proof (instant) → Finalized
```

Fast finality enables:
- Instant withdrawals (no 7-day wait)
- Stronger security (mathematical, not economic)
- No honest verifier assumption

#### zkSync Era (2023)

zkSync launched the first general-purpose zkEVM:

- **Native account abstraction**: Every account is a smart account
- **LLVM compiler**: Compile Solidity and Vyper to ZK circuits
- **Paymaster support**: Gas abstraction built-in

**Tradeoffs:**
- Not bytecode-equivalent (recompilation needed)
- Some EVM edge cases behave differently
- Higher computational overhead for proving

#### Polygon zkEVM (2023)

Polygon pursued bytecode-level EVM equivalence:

- **Type 2 zkEVM**: Run existing bytecode unchanged
- **Recursive proofs**: Aggregate multiple proofs for efficiency
- **Focus on compatibility**: Existing tools just work

**The zkEVM types:**

| Type | Description | Examples |
|------|-------------|----------|
| Type 1 | Ethereum-equivalent | (theoretical) |
| Type 2 | EVM-equivalent | Polygon zkEVM, Scroll |
| Type 3 | Almost EVM-equivalent | (transition state) |
| Type 4 | High-level equivalent | zkSync Era |

#### Scroll (2023)

Scroll focused on decentralized proving:

- **Open prover network**: Anyone can generate proofs
- **Type 2 equivalence**: Bytecode-compatible
- **Community-first**: Transparent development

#### The Proving Cost Problem

Early ZK rollups faced high proving costs:

```
2022: $0.01-$0.10 per proof (per batch)
2023: $0.001-$0.01 per proof (GPU optimization)
2024: $0.0001-$0.001 per proof (ASIC acceleration)
```

**What changed:**
- Hardware acceleration (GPUs, then ASICs)
- Recursive proofs (prove proofs)
- Better circuit design
- Prover market competition

**Developer Lesson:** ZK proving costs dropped 100x in two years. Assumptions about "too expensive" technology age quickly.

### Era 3: The Blob Era (2024-2026)

EIP-4844 (Dencun upgrade, March 2024) transformed L2 economics.

#### The Data Availability Bottleneck

Before blobs, L2s posted data to calldata:
- **16 gas per byte** for calldata
- Competes with L1 execution for block space
- Expensive during high L1 activity

L2 costs were dominated by data posting, not computation.

#### EIP-4844: Proto-Danksharding

Blobs create a separate data market, the most significant L2 cost reduction since rollups launched.

**Type 3 Transaction Format:**

```
Type 3 (Blob) Transaction Fields:
├── Standard EIP-1559 fields:
│   ├── nonce, gasLimit, to, value, data
│   ├── maxFeePerGas
│   └── maxPriorityFeePerGas
│
├── New blob fields:
│   ├── max_fee_per_blob_gas    # Max willing to pay per blob gas
│   ├── blob_versioned_hashes   # Commitments to blob contents
│   └── Sidecar (not in tx hash):
│       ├── blobs[]             # The actual blob data (~128 KB each)
│       ├── commitments[]       # KZG commitments
│       └── proofs[]            # KZG proofs
│
└── Blob pricing:
    ├── Target: 3 blobs/block (393 KB)
    ├── Max: 6 blobs/block (786 KB)
    ├── Base fee adjusts to hit target
    └── Separate from regular gas market
```

**KZG Commitments:**

KZG (Kate-Zaverucha-Goldberg) polynomial commitments enable efficient blob verification:
- Commit to blob data with a 48-byte commitment
- Prove any evaluation without revealing full blob
- Enables future data availability sampling (DAS)

```
Full Danksharding (future):
├── 16+ MB of blobs per block
├── Data availability sampling (DAS)
│   └── Nodes verify random samples, not full blobs
├── No need to download all data
└── 100x+ more capacity than current 4844
```

Blobs create a separate data market:

```
┌─────────────────────────────────────────────────────────────┐
│                    Blob Transaction                          │
│  ┌─────────────────────┐  ┌─────────────────────────────┐  │
│  │  Regular Tx Fields  │  │  Blob Data (up to 6 blobs)  │  │
│  │  (to, value, data)  │  │  ~128 KB per blob           │  │
│  └─────────────────────┘  └─────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

**Key characteristics:**
- **Temporary storage**: Pruned after ~18 days
- **Separate fee market**: `blobBaseFee` independent of gas
- **Target: 3 blobs/block**: ~0.375 MB/block capacity
- **KZG commitments**: Cryptographic commitments to blob data

#### The Economic Impact

```
Before EIP-4844:
├── L2 tx cost: $0.10-$1.00
├── Data posting: 80-90% of cost
└── Limited by calldata space

After EIP-4844:
├── L2 tx cost: $0.001-$0.01
├── Data posting: 50-70% of cost (but much cheaper)
└── 10-100x cost reduction
```

**Real-world impact (March 2024 onward):**
- Arbitrum fees dropped 90%+
- Base became viable for micropayments
- New use cases emerged (on-chain gaming, social)

#### Data Availability Beyond Ethereum

Alternative DA layers emerged:

| DA Layer | Approach | Status |
|----------|----------|--------|
| **Celestia** | Modular DA, DAS | Live (2023) |
| **EigenDA** | Restaked security | Live (2024) |
| **Avail** | DA-focused chain | Live (2024) |
| **Ethereum blobs** | Native to L1 | Live (2024) |

**Tradeoff:** Using alternative DA is cheaper but has weaker security guarantees than Ethereum blobs.

<Callout type="note" title="ETC and Blob Transactions">
Ethereum Classic does not implement EIP-4844. As a proof-of-work chain without L2 infrastructure, blob demand doesn't exist. If L2 development occurs on ETC, alternative DA solutions could be explored.
</Callout>

### Era 4: The Present and Beyond (2025-2026)

The L2 landscape continues evolving:

#### Shared Sequencing

Current problem: Each L2 has its own sequencer, making cross-L2 transactions slow.

**Solutions emerging:**
- **Espresso**: Shared sequencer for atomic cross-L2 transactions
- **Astria**: Decentralized shared sequencing layer
- **Based sequencing**: L1 validators sequence L2 transactions

#### Based Rollups

**The idea:** L1 validators sequence L2 transactions, maximizing decentralization.

```
Traditional Rollup:
User → Centralized Sequencer → L1

Based Rollup:
User → L1 Validators → L1
```

**Tradeoffs:**
- ✅ Maximum decentralization (no separate sequencer)
- ✅ L1-level censorship resistance
- ❌ Higher latency (L1 block times)
- ❌ MEV captured by L1, not L2

#### ZK Coprocessors

ZK proofs for computation, not just rollups:

```
On-chain:            Off-chain (ZK coprocessor):
├── Store data       ├── Heavy computation
├── Verify proof     ├── Generate proof
└── Update state     └── Return result + proof
```

**Examples:**
- **Axiom**: Prove historical blockchain data
- **RISC Zero**: General-purpose ZK VM
- **Succinct**: ZK proofs for any computation

**Use case:** Prove "this address held 100 tokens 1000 blocks ago" without storing all historical state on-chain.

## Rollup Deep Dive

### Optimistic Rollup Mechanics

#### Fraud Proofs

```solidity
// Simplified optimistic rollup contract
contract OptimisticRollup {
    bytes32 public stateRoot;
    uint256 public constant CHALLENGE_PERIOD = 7 days;

    struct Batch {
        bytes32 newStateRoot;
        uint256 timestamp;
        bool finalized;
    }

    mapping(uint256 => Batch) public batches;

    function submitBatch(
        bytes32 newStateRoot,
        bytes calldata txData
    ) external {
        // Anyone can submit (permissionless in theory)
        batches[batchId] = Batch(newStateRoot, block.timestamp, false);
    }

    function challengeBatch(
        uint256 batchId,
        bytes calldata fraudProof
    ) external {
        Batch storage batch = batches[batchId];
        require(block.timestamp < batch.timestamp + CHALLENGE_PERIOD);

        // Verify fraud proof
        if (verifyFraud(fraudProof)) {
            // Revert batch, slash operator
            delete batches[batchId];
        }
    }

    function finalizeBatch(uint256 batchId) external {
        Batch storage batch = batches[batchId];
        require(block.timestamp >= batch.timestamp + CHALLENGE_PERIOD);
        require(!batch.finalized);

        stateRoot = batch.newStateRoot;
        batch.finalized = true;
    }
}
```

#### The 7-Day Window

Why 7 days?
- Enough time for challengers to detect fraud
- Enough time to submit proof even under L1 congestion
- Balance between security and UX

**Fast exits** (Hop, Across, Stargate) front liquidity for users who can't wait:

```
User wants to withdraw 1 ETH from Arbitrum immediately:
├── User locks 1 ETH in withdrawal contract
├── Liquidity provider pays user 0.995 ETH on L1 now
├── 7 days later, LP claims the 1 ETH from rollup
└── LP profits ~0.5% for providing liquidity
```

### ZK Rollup Mechanics

#### Validity Proofs

```solidity
// Simplified ZK rollup contract
contract ZKRollup {
    bytes32 public stateRoot;
    IVerifier public verifier;

    function submitBatch(
        bytes32 newStateRoot,
        bytes calldata txData,
        bytes calldata proof
    ) external {
        // Verify ZK proof on-chain
        require(
            verifier.verify(stateRoot, newStateRoot, txData, proof),
            "Invalid proof"
        );

        // Immediately update state (no challenge period!)
        stateRoot = newStateRoot;
    }
}
```

#### Proof Generation

```
Batch of 1000 transactions
        │
        ▼
┌──────────────────────────┐
│    Prover (off-chain)    │
│  - Execute transactions  │
│  - Generate witness      │
│  - Compute ZK proof      │
│  - ~minutes to hours     │
└──────────────────────────┘
        │
        ▼
Proof (~256 bytes) + batch data
        │
        ▼
┌──────────────────────────┐
│  L1 Verifier Contract    │
│  - Verify proof (~200k gas)│
│  - Update state root     │
└──────────────────────────┘
```

### Rollup Comparison

| Aspect | Optimistic | ZK |
|--------|------------|-----|
| **Finality** | 7 days | Minutes |
| **Proof cost** | Low (only if challenged) | High (every batch) |
| **Security model** | 1-of-N honest verifier | Mathematical validity |
| **EVM compatibility** | Excellent | Good to excellent |
| **Tech maturity** | Production | Production |
| **Examples** | Arbitrum, Optimism, Base | zkSync, Polygon zkEVM, Scroll |

**Which to choose?**
- Need instant finality? → ZK
- Need maximum EVM compatibility? → Optimistic
- Building an ecosystem? → Consider OP Stack
- Low-value, high-frequency? → Whichever is cheapest

![Layer 2 Rollup Architecture](/images/diagrams/ch23-l2-architecture.svg)

## Building for L2

### Deployment

Most L2s are EVM-equivalent—same code, same tools:

```typescript
// foundry.toml
[rpc_endpoints]
arbitrum = "https://arb1.arbitrum.io/rpc"
optimism = "https://mainnet.optimism.io"
base = "https://mainnet.base.org"

// Deploy with Foundry
// forge create --rpc-url arbitrum --private-key $KEY src/Contract.sol:Contract
```

```typescript
// viem example
import { createWalletClient, http } from 'viem'
import { arbitrum, base, optimism } from 'viem/chains'

const client = createWalletClient({
  chain: arbitrum, // or base, optimism, etc.
  transport: http(),
})
```

### L1 ↔ L2 Communication

Rollups have native messaging systems:

```solidity
// Optimism: Send message from L1 to L2
interface ICrossDomainMessenger {
    function sendMessage(
        address target,
        bytes memory message,
        uint32 gasLimit
    ) external;
}

function sendToL2(address l2Contract, bytes memory data) external {
    messenger.sendMessage(l2Contract, data, 1_000_000);
}
```

```solidity
// Arbitrum: Send message from L1 to L2
interface IInbox {
    function createRetryableTicket(
        address to,
        uint256 l2CallValue,
        uint256 maxSubmissionCost,
        address excessFeeRefundAddress,
        address callValueRefundAddress,
        uint256 gasLimit,
        uint256 maxFeePerGas,
        bytes calldata data
    ) external payable returns (uint256);
}
```

### Bridging Assets

```solidity
// Simplified canonical bridge
contract Bridge {
    mapping(address => address) public l1ToL2Token;

    function depositERC20(
        address l1Token,
        uint256 amount,
        address l2Recipient
    ) external {
        // Lock tokens on L1
        IERC20(l1Token).transferFrom(msg.sender, address(this), amount);

        // Emit event for L2 minting
        emit Deposit(l1Token, l1ToL2Token[l1Token], msg.sender, l2Recipient, amount);
    }
}
```

### Handling Withdrawal Delays

For optimistic rollups, design around the 7-day wait:

```solidity
// Don't: Force users to wait
function withdraw(uint256 amount) external {
    // User waits 7 days...
}

// Do: Use fast bridge or liquidity network
function fastWithdraw(uint256 amount) external {
    // Request fast bridge (pays small fee)
    fastBridge.requestWithdrawal(amount);
}
```

### Cross-L2 Considerations

```
User on Arbitrum wants to swap on Base:

Option 1: Slow (canonical bridges)
Arbitrum → L1 (7 days) → Base

Option 2: Fast (third-party bridges)
Arbitrum → Hop/Across → Base (minutes)

Option 3: Atomic (shared sequencing, future)
Arbitrum ↔ Base (single transaction)
```

## What We Learned

### Lesson 1: Data Availability Is the Bottleneck

Plasma failed because users couldn't prove their state without data. Rollups succeed by posting all data to L1. EIP-4844 made it affordable.

### Lesson 2: Economics Drive Adoption

```
L2 Adoption Timeline:
2021: "Use L2 for ideology (decentralization)"
2022: "Use L2 for cost (10x cheaper)"
2024: "Use L2 because it's obvious (100x cheaper)"
```

When L2 fees dropped below $0.01, adoption exploded.

### Lesson 3: Composability Creates Lock-In

Once DeFi primitives exist on an L2, liquidity follows. Arbitrum's early DeFi ecosystem created a moat. Base's Coinbase integration created a different moat (fiat onramp).

### Lesson 4: Centralization Is the Temporary Tradeoff

Most L2s launched with centralized sequencers for performance and upgradeability. Decentralization is a spectrum:

```
2021: Fully centralized (single sequencer, upgradeable contracts)
2023: Permissioned set (multiple sequencers)
2024: Fraud proofs live (Arbitrum)
2025: Decentralized proving (Scroll)
Future: Based sequencing (maximum decentralization)
```

### Lesson 5: The Stack Keeps Modularizing

```
2020: Monolithic L1 (Ethereum does everything)

2024: Modular stack
      ├── Execution: L2 rollups
      ├── Settlement: L1
      ├── Data availability: Blobs, Celestia
      └── Sequencing: Shared sequencers
```

## The Dependency Position

### What L2s Enable

```
              ┌─────────────────────────────────────┐
              │       NEW POSSIBILITIES             │
              │  (On-chain gaming, social, micro-  │
              │   payments, high-frequency DeFi)   │
              └─────────────────┬───────────────────┘
                                │
                                ▼
              ┌─────────────────────────────────────┐
              │          L2 ROLLUPS                 │
              │  (Cheap execution, fast finality)  │
              └─────────────────┬───────────────────┘
                                │
                                ▼
              ┌─────────────────────────────────────┐
              │         DATA AVAILABILITY           │
              │  (Blobs, Celestia, EigenDA)        │
              └─────────────────┬───────────────────┘
                                │
                                ▼
              ┌─────────────────────────────────────┐
              │           ETHEREUM L1               │
              │  (Security, settlement, ordering)  │
              └─────────────────────────────────────┘
```

### What Depends on L2s

- **Low-value transactions**: Payments, gaming, social
- **High-frequency operations**: Orderbook DEXs, perpetuals
- **New user segments**: Users priced out of L1
- **New use cases**: Fully on-chain games, real-time apps

## Conclusions

L2 scaling has evolved through distinct eras:

1. **Era 0 (2017-2019)**: Plasma and state channels—learned that data availability is critical
2. **Era 1 (2020-2021)**: Optimistic rollups proved the model works
3. **Era 2 (2022-2024)**: ZK rollups matured, proving costs dropped
4. **Era 3 (2024+)**: Blobs made L2s economically dominant

**For developers:**
- L2s are EVM-compatible—your code works unchanged
- Choose L2 based on ecosystem, not just technology
- Design for cross-L2 world (bridging, messaging)
- Account for finality differences in UX

The future is multi-L2. Users won't know which rollup they're on—wallets will abstract it away. But builders need to understand the stack to make good decisions about where to deploy and how to design cross-chain experiences.

The EVM is the constant across L1, L2, and beyond.

## Sequencer Economics and Security

Understanding L2 economics requires understanding sequencer incentives.

### Sequencer Revenue Model

```
Sequencer Revenue:
├── L2 transaction fees collected from users
├── MEV extracted from transaction ordering
├── Priority tips for fast inclusion
│
└── Minus:
    ├── L1 data posting costs (calldata or blobs)
    ├── L1 state commitment costs
    ├── ZK prover costs (for ZK rollups)
    └── Infrastructure costs
```

**Profit margins vary dramatically:**
- Pre-EIP-4844: Often negative or thin margins
- Post-EIP-4844: Substantial margins possible
- Competition: L2s competing on fees erodes margins

### Sequencer Centralization Risks

Most L2s launched with centralized sequencers—a practical choice for iteration speed but with known risks:

| Risk | Impact | Mitigation |
|------|--------|------------|
| Censorship | Sequencer can exclude transactions | Forced inclusion via L1 |
| MEV extraction | Sequencer captures all MEV | Proposer-builder separation |
| Downtime | L2 unavailable if sequencer fails | Force exit to L1 |
| Regulatory pressure | Single point of legal attack | Geographic distribution |

**Forced Inclusion**: All major rollups allow users to submit transactions directly to L1 if the sequencer censors them. This is the ultimate censorship resistance backstop:

```solidity
// User bypasses sequencer by submitting to L1 inbox
function forceInclude(bytes calldata txData) external {
    // Transaction queued for L2 processing
    // Sequencer MUST include within timeout
    inbox.enqueueTransaction(txData);
}
```

### Decentralization Roadmaps

| L2 | Current State | Decentralization Plan |
|----|---------------|----------------------|
| **Arbitrum** | Single sequencer | BoLD fraud proofs live; sequencer decentralization planned |
| **Optimism** | Single sequencer | Cannon fault proofs live; OP Stack sequencer set |
| **Base** | Single sequencer | Inherits Optimism roadmap |
| **zkSync** | Single sequencer + prover | Decentralized prover network planned |
| **Scroll** | Single sequencer | Open prover network live |

### L2 Security Stages

The L2Beat "stage" classification helps assess rollup security:

```
Stage 0: "Training wheels"
├── Centralized sequencer
├── Upgradeable contracts with no delay
├── No fraud/validity proofs live
└── User funds at operator risk

Stage 1: "Limited training wheels"
├── Fraud/validity proofs live
├── Time-locked upgrades (7+ days)
├── Emergency exit path works
└── 6/8 security council threshold

Stage 2: "Full rollup"
├── Decentralized sequencing
├── 30+ day upgrade delay (or immutable)
├── Permissionless proving
└── No single point of failure
```

**Current status (2026):**
- Arbitrum: Stage 1 (BoLD fraud proofs live)
- Optimism: Stage 1 (Cannon fault proofs live)
- zkSync Era: Stage 0 (proofs in progress)
- Most others: Stage 0

<Warning>
Most L2s today rely on security councils with upgrade power. Users trust that 4+ of 8 council members won't collude to steal funds. This is a significant trust assumption often overlooked in "Ethereum security" claims.
</Warning>

## L2 MEV Dynamics

MEV on L2 differs from L1 MEV.

### Sequencer MEV Monopoly

Unlike L1's competitive block building:
- L2 sequencer sees all transactions
- No competition for block inclusion
- Sequencer can extract all available MEV

```
L1: User → Mempool → Searchers compete → Builder → Validator
L2: User → Sequencer (monopoly) → L1 batch
```

### MEV Capture Strategies

| Strategy | Description | L2 Impact |
|----------|-------------|-----------|
| **Passive** | Sequencer doesn't extract MEV | User-friendly; leaving money on table |
| **Active** | Sequencer runs MEV strategies | Profitable; potentially harms users |
| **MEV sharing** | Return MEV to protocols/users | Optimism's vision with sequencer decentralization |
| **MEV auctions** | Auction ordering rights | Flashbots-style for L2 |

**Optimism's approach:** Revenue sharing model where sequencer profits fund public goods.

**Base's approach:** Coinbase runs sequencer; no explicit MEV policy published.

**Arbitrum's approach:** Timeboost auctions time-priority within blocks.

## Interoperability Challenges

The multi-L2 world creates new problems.

### Liquidity Fragmentation

```
Before L2s:
All liquidity on Ethereum L1

After L2s:
├── Ethereum L1: $X
├── Arbitrum: $Y
├── Base: $Z
├── Optimism: $W
├── zkSync: $V
└── ... (dozens more)
```

Result: Worse execution for users unless bridging is seamless.

### Bridge Security Hierarchy

| Bridge Type | Security | Speed | Cost |
|-------------|----------|-------|------|
| **Canonical (native)** | L1 security | 7 days (OR) / minutes (ZK) | Gas costs |
| **Liquidity network** | LP bond | Minutes | Fee (~0.1-0.5%) |
| **Third-party bridge** | Own validator set | Fast | Variable |

**Historical bridge losses (through 2024):**
- Ronin: $625M (2022)
- Wormhole: $320M (2022)
- Nomad: $190M (2022)

Third-party bridges remain the weakest link in cross-L2 security.

### Emerging Solutions

**Superchain vision (Optimism):** Shared bridge, atomic messaging between OP Stack chains.

**AggLayer (Polygon):** Unified settlement layer across Polygon chains.

**Shared sequencing:** Atomic transactions across L2s via shared ordering.

```
Future: User sends "cross-L2 intent"
├── Shared sequencer orders on both L2s atomically
├── Execution happens simultaneously
├── No bridge risk, no liquidity fragmentation
└── But: Requires shared sequencer infrastructure
```

## Key Figures in L2 Development

### Ed Felten (Arbitrum / Offchain Labs)

**Background:** B.S. Physics, Caltech (1985); Ph.D. Computer Science, University of Washington (1993). Robert E. Kahn Professor Emeritus of Computer Science at Princeton University. Founding Director, Princeton Center for Information Technology Policy.

**Government service:** First Chief Technologist of the FTC (2011); Deputy U.S. Chief Technology Officer at the White House (2015-2017).

**Contribution:** Co-founded Offchain Labs (September 2018) with Princeton Ph.D. students Steven Goldfeder and Harry Kalodner. Developed Arbitrum as a Princeton research project, later licensing the technology for commercial deployment. Arbitrum One processed over 1 billion transactions by October 2023.

### Steven Goldfeder (Arbitrum / Offchain Labs)

**Background:** B.S. Mathematics and Computer Science, Yeshiva University; Ph.D. Computer Science, Princeton University (2018), advised by Arvind Narayanan. NSF Graduate Research Fellow with research in cryptography and digital currencies.

**Publications:** Co-authored "Bitcoin and Cryptocurrency Technologies" (Princeton University Press, 2016) and "Arbitrum: Scalable, private smart contracts" (USENIX Security 2018).

**Contribution:** CEO and Co-founder of Offchain Labs. Led technical development of Arbitrum, which became the highest-TVL Ethereum L2.

### Eli Ben-Sasson (StarkWare)

**Background:** Ph.D. Computer Science, Hebrew University of Jerusalem (2001). Postdoc at Harvard and MIT. Professor at Technion (2005-2020).

**Inventions:** Co-invented STARKs and FRI protocols (2018)—zero-knowledge proofs with post-quantum security, no trusted setup, and quasi-linear prover time. Co-inventor of Zerocash protocol; founding scientist of Zcash.

**Contribution:** Co-founded StarkWare Industries (2018). StarkWare valued at $8B at peak; StarkNet is a leading ZK-rollup with a unique Cairo programming language.

### Karl Floersch (Optimism)

**Background:** B.S. Computer Science, Stony Brook University. College roommate of Hayden Adams (Uniswap founder).

**Career path:** Blockchain engineer at ConsenSys (built Ujo Music) → Ethereum Foundation researcher (2017-2020), contributed to PoS research → Co-founded Plasma Group with Jinglan Wang → Plasma Group evolved into Optimism.

**Contribution:** CTO then CEO of OP Labs. Architected the Optimistic Rollup design. Created Retroactive Public Goods Funding (RPGF) mechanism. Oversaw OP Stack release enabling Coinbase's Base and the Superchain vision.

## Common Misconceptions

### "Rollups are sidechains"

**Reality:** Fundamental difference. Sidechains have their own security (validators, consensus). Rollups inherit L1 security through proofs—either fraud proofs (optimistic) or validity proofs (ZK). A sidechain failure loses user funds. A rollup with functional proofs can always be reconstructed from L1 data.

### "ZK rollups are always more secure than optimistic"

**Reality:** Both provide L1 security when implemented correctly. Trade-offs differ:
- ZK: Faster finality, but complex prover systems
- Optimistic: Simpler, but relies on honest verifier assumption

A buggy ZK prover is worse than a working optimistic system.

### "L2s make Ethereum less valuable"

**Reality:** L2s increase demand for ETH:
- Data posting uses ETH for gas
- Bridged ETH is locked on L1
- L2 activity generates L1 settlement fees
- EIP-4844 blob fees accrue to validators

L2s extend Ethereum's security to more use cases.

### "We'll eventually have one dominant L2"

**Reality:** The trend is opposite—proliferation, not consolidation. Different L2s serve different niches:
- Base: Fiat onramp (Coinbase integration)
- Arbitrum: DeFi ecosystem (first-mover liquidity)
- zkSync: Native account abstraction
- StarkNet: Non-EVM, Cairo development

Multi-L2 with interoperability is the likely equilibrium.

## The Rollup-as-a-Service Economy

Deploying custom rollups became commoditized by 2024.

### RaaS Providers

| Provider | Stack | Notable Deployments |
|----------|-------|---------------------|
| **Conduit** | OP Stack | Aevo, Zora, Mode |
| **Caldera** | OP Stack, Arbitrum Orbit | Manta, Injective |
| **Gelato** | OP Stack, Polygon CDK | Lisk, Reya |
| **AltLayer** | Multiple | Restaked rollups |
| **Ankr** | OP Stack | Various |

### Custom Rollup Economics

```
DIY Rollup:
├── Development: $500K-2M (6-12 months)
├── Security audits: $100K-500K
├── Sequencer infrastructure: $10K-50K/month
└── Ongoing maintenance: 2-5 engineers

RaaS Rollup:
├── Setup: Days to weeks
├── Cost: $5K-50K/month + fees
├── Infrastructure: Managed
└── Tradeoff: Less customization
```

### When Custom Rollups Make Sense

| Use Case | Benefit of Custom Rollup |
|----------|-------------------------|
| High-volume DEX | Custom ordering, lower fees |
| Gaming | Gasless transactions, custom mechanics |
| Enterprise | Permissioned, compliant |
| Special execution | Non-EVM, custom precompiles |

**The trend:** App-specific rollups for high-value applications, general-purpose L2s for everything else.

## L2 Adoption Metrics (2026)

| Metric | L1 Ethereum | All L2s Combined |
|--------|-------------|------------------|
| Daily transactions | ~1M | ~10M+ |
| Daily active addresses | ~400K | ~2M+ |
| TVL | ~$50B | ~$40B+ |
| Average tx cost | $2-5 | $0.001-0.10 |

**The inflection point:** L2 transaction volume exceeded L1 in 2024 and continues growing.
