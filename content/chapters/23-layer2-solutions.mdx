---
title: Layer 2 Solutions
description: Rollups, EIP-4844 blobs, and the L2 landscape evolution
chapter: 23
---

# Layer 2 Solutions

Blockchain scalability has been the defining challenge of the EVM ecosystem. The base layer of Ethereum processes 15-30 transactions per second. That's nowhere near enough for global adoption. Layer 2 solutions are how we scale—moving execution off-chain while inheriting security from L1.

This chapter traces the evolution of L2 scaling, from early failures through the rollup era to the blob-powered present.

## The Scalability Problem

### The Trilemma

Blockchains face fundamental tradeoffs:

```
                    Decentralization
                          ▲
                         / \
                        /   \
                       /     \
                      /       \
                     /_________\
              Security ◀─────────▶ Scalability
```

- **Decentralization** — Many independent validators
- **Security** — Resistance to attacks
- **Scalability** — High transaction throughput

Traditional databases sacrifice decentralization for scalability. Early blockchains sacrificed scalability for decentralization. The challenge: improve throughput without compromising the other two.

### Why L2, Not L1 Scaling?

L1 scaling options have limits:

| Approach | Tradeoff |
|----------|----------|
| Bigger blocks | Higher hardware requirements → less decentralization |
| Faster blocks | More orphan blocks, weaker consensus |
| Sharding | Complex, years away from full implementation |

L2 solutions bypass these tradeoffs by moving execution off-chain while using L1 for security and data availability.

## L2 Evolution Timeline

### Era 0: The Early Attempts (2017-2019)

The first scaling proposals tried to move transactions off-chain with minimal L1 footprint.

#### State Channels

**The idea:** Lock funds on-chain, transact off-chain, settle final state.

```
1. Alice and Bob each lock 10 ETH on-chain
2. They exchange signed messages off-chain (Alice pays Bob 1 ETH, etc.)
3. Either party can close the channel with the latest signed state
4. Final balances settled on-chain
```

**Why it worked:**
- Unlimited transactions per second between participants
- Only two on-chain transactions (open and close)
- Bitcoin's Lightning Network proved the concept

**Why it struggled:**
- Requires both parties online
- Channel capacity limited by locked funds
- Hub-and-spoke networks have centralization pressure
- Complex for general-purpose computation (not just payments)

**Ethereum examples:** Raiden Network (launched 2020), Connext

#### Plasma

**The idea:** Child chains with cryptographic commitments to L1.

```
L1 commits:     Block 1 → Block 2 → Block 3 → ...
                   ↓         ↓         ↓
Plasma chain:   Subtree of transactions validated off-chain
```

**The 2017 vision:** Plasma chains would handle millions of transactions, posting only Merkle roots to Ethereum.

**Why it failed:**
1. **Data availability problem**: If operators withhold data, users can't prove their balances
2. **Mass exit scenarios**: If chain becomes invalid, everyone exits at once → L1 congestion
3. **Complexity**: Different Plasma variants (MVP, Cash, Debit) all had edge cases
4. **Limited functionality**: Hard to support general smart contracts

**Developer Lesson:** Plasma taught us that data availability is the critical bottleneck. You can't just post commitments—users need the actual data to verify and exit.

<Callout type="note">
Plasma research wasn't wasted. The data availability problem it exposed directly led to rollup designs and later to EIP-4844 blobs.
</Callout>

#### Sidechains: A Different Tradeoff

Sidechains run their own consensus but bridge to Ethereum. Unlike Plasma, they don't rely on Ethereum for security—just for asset transfers.

**Polygon PoS (2020-present)**

Polygon (originally Matic) launched as a Plasma-like solution but evolved into a proof-of-stake sidechain:

- **Own validator set**: ~100 validators staking MATIC
- **Checkpoint commitments**: Merkle roots posted to Ethereum
- **EVM-compatible**: Same tooling, easy migration
- **Cheap and fast**: Fraction of Ethereum fees, ~2 second blocks

```
Ethereum ←────────────────────────────→ Polygon PoS
         Bridge contracts              Own consensus
         Checkpoints every ~30 min     Own validators
         Final settlement              Own data availability
```

**The Sidechain Tradeoff:**

| Aspect | Rollups | Sidechains (Polygon PoS) |
|--------|---------|--------------------------|
| Security source | Ethereum | Own validators |
| Data availability | Posted to Ethereum | Own chain |
| Trust assumption | Ethereum consensus | Sidechain consensus |
| Cost | Higher (L1 data costs) | Lower (independent chain) |
| Censorship resistance | Inherits from Ethereum | Own validator set |

**Why Polygon Succeeded:**

1. **First mover**: Scaling solution available before rollups matured
2. **EVM equivalence**: No code changes needed for most dApps
3. **Business development**: Active ecosystem partnerships
4. **Cheap transactions**: Enabled use cases impossible on L1

**The Polygon Pivot:**

Polygon evolved from "sidechain" to "multi-chain ecosystem":
- **Polygon zkEVM**: Type 2 ZK rollup (true L2 security)
- **Polygon CDK**: Chain development kit for custom rollups
- **Polygon Miden**: zkSTARK-based rollup (in development)
- **AggLayer**: Unified bridge and liquidity across Polygon chains

<Callout type="info">
**Builder Perspective**: Polygon PoS remains useful for cost-sensitive applications where decentralization from Ethereum's validator set isn't critical. For higher security needs, rollups (including Polygon zkEVM) offer Ethereum-grade security.
</Callout>

### Era 1: Optimistic Rollups Emerge (2020-2021)

The insight: post all transaction data to L1, but execute off-chain. Anyone can verify; challenge if wrong.

#### The Rollup Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                        Layer 2 Rollup                        │
│  ┌────────┐  ┌────────┐  ┌────────┐                         │
│  │  Tx 1  │  │  Tx 2  │  │  Tx 3  │  ... (1000s of txs)    │
│  └────────┘  └────────┘  └────────┘                         │
│                    │                                         │
│                    ▼                                         │
│              ┌──────────────────┐                           │
│              │  Batch (Sequencer) │                          │
│              └────────┬─────────┘                           │
│                       │                                      │
└───────────────────────┼──────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│                     Layer 1 (Ethereum)                        │
│              ┌──────────────────────────┐                     │
│              │  State Root + Tx Data    │                     │
│              └──────────────────────────┘                     │
└───────────────────────────────────────────────────────────────┘
```

**Key difference from Plasma:** All transaction data is posted to L1. Anyone can reconstruct state from on-chain data alone.

#### Optimism Launch (2021)

Optimism pioneered optimistic rollups on mainnet:

- **OVM (Optimistic Virtual Machine)**: Interpreted EVM execution
- **7-day challenge period**: Time for fraud proofs
- **Single sequencer**: Initially centralized for performance

**Early challenges:**
- OVM wasn't fully EVM-equivalent (some contracts needed modification)
- High fees (still using calldata, pre-blobs)
- Centralized sequencer

#### Arbitrum Launch (2021)

Arbitrum took a different approach:

- **AVM (Arbitrum Virtual Machine)**: Different fraud proof mechanism
- **Multi-round dispute resolution**: More efficient fraud proofs
- **Earlier mainnet launch**: Beat Optimism to market

**Arbitrum's advantages:**
- Better EVM compatibility from the start
- More efficient fraud proofs (interactive proving)
- Larger ecosystem adoption

By late 2021:
- Arbitrum: ~$2B TVL
- Optimism: ~$500M TVL
- Both proving the rollup model worked

#### The OP Stack (2022)

Optimism open-sourced its rollup architecture as the "OP Stack":

```
OP Stack Components:
├── Execution: EVM-equivalent execution
├── Sequencing: Transaction ordering
├── Derivation: L1 data → L2 state
├── Settlement: Fraud proofs, withdrawals
└── Bridging: L1 ↔ L2 communication
```

This enabled:
- **Base (Coinbase)**: Launched 2023, fastest-growing L2
- **Mode**: DeFi-focused OP Stack chain
- **Zora**: NFT-focused OP Stack chain
- **World Chain**: Identity/Worldcoin's L2

**Developer Lesson:** Open-sourcing infrastructure creates ecosystems. The OP Stack's adoption proved that modular rollup architecture beats proprietary solutions.

### Era 2: ZK Rollup Maturity (2022-2024)

Zero-knowledge rollups use validity proofs instead of fraud proofs: prove execution was correct, don't assume and challenge.

#### The ZK Advantage

**Optimistic rollups:**
```
Submit batch → Wait 7 days → If no challenge → Finalized
```

**ZK rollups:**
```
Submit batch + proof → Verify proof (instant) → Finalized
```

Fast finality enables:
- Instant withdrawals (no 7-day wait)
- Stronger security (mathematical, not economic)
- No honest verifier assumption

#### zkSync Era (2023)

zkSync launched the first general-purpose zkEVM:

- **Native account abstraction**: Every account is a smart account
- **LLVM compiler**: Compile Solidity and Vyper to ZK circuits
- **Paymaster support**: Gas abstraction built-in

**Tradeoffs:**
- Not bytecode-equivalent (recompilation needed)
- Some EVM edge cases behave differently
- Higher computational overhead for proving

#### Polygon zkEVM (2023)

Polygon pursued bytecode-level EVM equivalence:

- **Type 2 zkEVM**: Run existing bytecode unchanged
- **Recursive proofs**: Aggregate multiple proofs for efficiency
- **Focus on compatibility**: Existing tools just work

**The zkEVM types:**

| Type | Description | Examples |
|------|-------------|----------|
| Type 1 | Ethereum-equivalent | (theoretical) |
| Type 2 | EVM-equivalent | Polygon zkEVM, Scroll |
| Type 3 | Almost EVM-equivalent | (transition state) |
| Type 4 | High-level equivalent | zkSync Era |

#### Scroll (2023)

Scroll focused on decentralized proving:

- **Open prover network**: Anyone can generate proofs
- **Type 2 equivalence**: Bytecode-compatible
- **Community-first**: Transparent development

#### The Proving Cost Problem

Early ZK rollups faced high proving costs:

```
2022: $0.01-$0.10 per proof (per batch)
2023: $0.001-$0.01 per proof (GPU optimization)
2024: $0.0001-$0.001 per proof (ASIC acceleration)
```

**What changed:**
- Hardware acceleration (GPUs, then ASICs)
- Recursive proofs (prove proofs)
- Better circuit design
- Prover market competition

**Developer Lesson:** ZK proving costs dropped 100x in two years. Assumptions about "too expensive" technology age quickly.

### Era 3: The Blob Era (2024-2026)

EIP-4844 (Dencun upgrade, March 2024) transformed L2 economics.

#### The Data Availability Bottleneck

Before blobs, L2s posted data to calldata:
- **16 gas per byte** for calldata
- Competes with L1 execution for block space
- Expensive during high L1 activity

L2 costs were dominated by data posting, not computation.

#### EIP-4844: Proto-Danksharding

Blobs create a separate data market:

```
┌─────────────────────────────────────────────────────────────┐
│                    Blob Transaction                          │
│  ┌─────────────────────┐  ┌─────────────────────────────┐  │
│  │  Regular Tx Fields  │  │  Blob Data (up to 6 blobs)  │  │
│  │  (to, value, data)  │  │  ~128 KB per blob           │  │
│  └─────────────────────┘  └─────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

**Key characteristics:**
- **Temporary storage**: Pruned after ~18 days
- **Separate fee market**: `blobBaseFee` independent of gas
- **Target: 3 blobs/block**: ~0.375 MB/block capacity
- **KZG commitments**: Cryptographic commitments to blob data

#### The Economic Impact

```
Before EIP-4844:
├── L2 tx cost: $0.10-$1.00
├── Data posting: 80-90% of cost
└── Limited by calldata space

After EIP-4844:
├── L2 tx cost: $0.001-$0.01
├── Data posting: 50-70% of cost (but much cheaper)
└── 10-100x cost reduction
```

**Real-world impact (March 2024 onward):**
- Arbitrum fees dropped 90%+
- Base became viable for micropayments
- New use cases emerged (on-chain gaming, social)

#### Data Availability Beyond Ethereum

Alternative DA layers emerged:

| DA Layer | Approach | Status |
|----------|----------|--------|
| **Celestia** | Modular DA, DAS | Live (2023) |
| **EigenDA** | Restaked security | Live (2024) |
| **Avail** | DA-focused chain | Live (2024) |
| **Ethereum blobs** | Native to L1 | Live (2024) |

**Tradeoff:** Using alternative DA is cheaper but has weaker security guarantees than Ethereum blobs.

<Callout type="note" title="ETC and Blob Transactions">
Ethereum Classic does not implement EIP-4844. As a proof-of-work chain without L2 infrastructure, blob demand doesn't exist. If L2 development occurs on ETC, alternative DA solutions could be explored.
</Callout>

### Era 4: The Present and Beyond (2025-2026)

The L2 landscape continues evolving:

#### Shared Sequencing

Current problem: Each L2 has its own sequencer, making cross-L2 transactions slow.

**Solutions emerging:**
- **Espresso**: Shared sequencer for atomic cross-L2 transactions
- **Astria**: Decentralized shared sequencing layer
- **Based sequencing**: L1 validators sequence L2 transactions

#### Based Rollups

**The idea:** L1 validators sequence L2 transactions, maximizing decentralization.

```
Traditional Rollup:
User → Centralized Sequencer → L1

Based Rollup:
User → L1 Validators → L1
```

**Tradeoffs:**
- ✅ Maximum decentralization (no separate sequencer)
- ✅ L1-level censorship resistance
- ❌ Higher latency (L1 block times)
- ❌ MEV captured by L1, not L2

#### ZK Coprocessors

ZK proofs for computation, not just rollups:

```
On-chain:            Off-chain (ZK coprocessor):
├── Store data       ├── Heavy computation
├── Verify proof     ├── Generate proof
└── Update state     └── Return result + proof
```

**Examples:**
- **Axiom**: Prove historical blockchain data
- **RISC Zero**: General-purpose ZK VM
- **Succinct**: ZK proofs for any computation

**Use case:** Prove "this address held 100 tokens 1000 blocks ago" without storing all historical state on-chain.

## Rollup Deep Dive

### Optimistic Rollup Mechanics

#### Fraud Proofs

```solidity
// Simplified optimistic rollup contract
contract OptimisticRollup {
    bytes32 public stateRoot;
    uint256 public constant CHALLENGE_PERIOD = 7 days;

    struct Batch {
        bytes32 newStateRoot;
        uint256 timestamp;
        bool finalized;
    }

    mapping(uint256 => Batch) public batches;

    function submitBatch(
        bytes32 newStateRoot,
        bytes calldata txData
    ) external {
        // Anyone can submit (permissionless in theory)
        batches[batchId] = Batch(newStateRoot, block.timestamp, false);
    }

    function challengeBatch(
        uint256 batchId,
        bytes calldata fraudProof
    ) external {
        Batch storage batch = batches[batchId];
        require(block.timestamp < batch.timestamp + CHALLENGE_PERIOD);

        // Verify fraud proof
        if (verifyFraud(fraudProof)) {
            // Revert batch, slash operator
            delete batches[batchId];
        }
    }

    function finalizeBatch(uint256 batchId) external {
        Batch storage batch = batches[batchId];
        require(block.timestamp >= batch.timestamp + CHALLENGE_PERIOD);
        require(!batch.finalized);

        stateRoot = batch.newStateRoot;
        batch.finalized = true;
    }
}
```

#### The 7-Day Window

Why 7 days?
- Enough time for challengers to detect fraud
- Enough time to submit proof even under L1 congestion
- Balance between security and UX

**Fast exits** (Hop, Across, Stargate) front liquidity for users who can't wait:

```
User wants to withdraw 1 ETH from Arbitrum immediately:
├── User locks 1 ETH in withdrawal contract
├── Liquidity provider pays user 0.995 ETH on L1 now
├── 7 days later, LP claims the 1 ETH from rollup
└── LP profits ~0.5% for providing liquidity
```

### ZK Rollup Mechanics

#### Validity Proofs

```solidity
// Simplified ZK rollup contract
contract ZKRollup {
    bytes32 public stateRoot;
    IVerifier public verifier;

    function submitBatch(
        bytes32 newStateRoot,
        bytes calldata txData,
        bytes calldata proof
    ) external {
        // Verify ZK proof on-chain
        require(
            verifier.verify(stateRoot, newStateRoot, txData, proof),
            "Invalid proof"
        );

        // Immediately update state (no challenge period!)
        stateRoot = newStateRoot;
    }
}
```

#### Proof Generation

```
Batch of 1000 transactions
        │
        ▼
┌──────────────────────────┐
│    Prover (off-chain)    │
│  - Execute transactions  │
│  - Generate witness      │
│  - Compute ZK proof      │
│  - ~minutes to hours     │
└──────────────────────────┘
        │
        ▼
Proof (~256 bytes) + batch data
        │
        ▼
┌──────────────────────────┐
│  L1 Verifier Contract    │
│  - Verify proof (~200k gas)│
│  - Update state root     │
└──────────────────────────┘
```

### Rollup Comparison

| Aspect | Optimistic | ZK |
|--------|------------|-----|
| **Finality** | 7 days | Minutes |
| **Proof cost** | Low (only if challenged) | High (every batch) |
| **Security model** | 1-of-N honest verifier | Mathematical validity |
| **EVM compatibility** | Excellent | Good to excellent |
| **Tech maturity** | Production | Production |
| **Examples** | Arbitrum, Optimism, Base | zkSync, Polygon zkEVM, Scroll |

**Which to choose?**
- Need instant finality? → ZK
- Need maximum EVM compatibility? → Optimistic
- Building an ecosystem? → Consider OP Stack
- Low-value, high-frequency? → Whichever is cheapest

## Building for L2

### Deployment

Most L2s are EVM-equivalent—same code, same tools:

```typescript
// foundry.toml
[rpc_endpoints]
arbitrum = "https://arb1.arbitrum.io/rpc"
optimism = "https://mainnet.optimism.io"
base = "https://mainnet.base.org"

// Deploy with Foundry
// forge create --rpc-url arbitrum --private-key $KEY src/Contract.sol:Contract
```

```typescript
// viem example
import { createWalletClient, http } from 'viem'
import { arbitrum, base, optimism } from 'viem/chains'

const client = createWalletClient({
  chain: arbitrum, // or base, optimism, etc.
  transport: http(),
})
```

### L1 ↔ L2 Communication

Rollups have native messaging systems:

```solidity
// Optimism: Send message from L1 to L2
interface ICrossDomainMessenger {
    function sendMessage(
        address target,
        bytes memory message,
        uint32 gasLimit
    ) external;
}

function sendToL2(address l2Contract, bytes memory data) external {
    messenger.sendMessage(l2Contract, data, 1_000_000);
}
```

```solidity
// Arbitrum: Send message from L1 to L2
interface IInbox {
    function createRetryableTicket(
        address to,
        uint256 l2CallValue,
        uint256 maxSubmissionCost,
        address excessFeeRefundAddress,
        address callValueRefundAddress,
        uint256 gasLimit,
        uint256 maxFeePerGas,
        bytes calldata data
    ) external payable returns (uint256);
}
```

### Bridging Assets

```solidity
// Simplified canonical bridge
contract Bridge {
    mapping(address => address) public l1ToL2Token;

    function depositERC20(
        address l1Token,
        uint256 amount,
        address l2Recipient
    ) external {
        // Lock tokens on L1
        IERC20(l1Token).transferFrom(msg.sender, address(this), amount);

        // Emit event for L2 minting
        emit Deposit(l1Token, l1ToL2Token[l1Token], msg.sender, l2Recipient, amount);
    }
}
```

### Handling Withdrawal Delays

For optimistic rollups, design around the 7-day wait:

```solidity
// Don't: Force users to wait
function withdraw(uint256 amount) external {
    // User waits 7 days...
}

// Do: Use fast bridge or liquidity network
function fastWithdraw(uint256 amount) external {
    // Request fast bridge (pays small fee)
    fastBridge.requestWithdrawal(amount);
}
```

### Cross-L2 Considerations

```
User on Arbitrum wants to swap on Base:

Option 1: Slow (canonical bridges)
Arbitrum → L1 (7 days) → Base

Option 2: Fast (third-party bridges)
Arbitrum → Hop/Across → Base (minutes)

Option 3: Atomic (shared sequencing, future)
Arbitrum ↔ Base (single transaction)
```

## What We Learned

### Lesson 1: Data Availability Is the Bottleneck

Plasma failed because users couldn't prove their state without data. Rollups succeed by posting all data to L1. EIP-4844 made it affordable.

### Lesson 2: Economics Drive Adoption

```
L2 Adoption Timeline:
2021: "Use L2 for ideology (decentralization)"
2022: "Use L2 for cost (10x cheaper)"
2024: "Use L2 because it's obvious (100x cheaper)"
```

When L2 fees dropped below $0.01, adoption exploded.

### Lesson 3: Composability Creates Lock-In

Once DeFi primitives exist on an L2, liquidity follows. Arbitrum's early DeFi ecosystem created a moat. Base's Coinbase integration created a different moat (fiat onramp).

### Lesson 4: Centralization Is the Temporary Tradeoff

Most L2s launched with centralized sequencers for performance and upgradeability. Decentralization is a spectrum:

```
2021: Fully centralized (single sequencer, upgradeable contracts)
2023: Permissioned set (multiple sequencers)
2024: Fraud proofs live (Arbitrum)
2025: Decentralized proving (Scroll)
Future: Based sequencing (maximum decentralization)
```

### Lesson 5: The Stack Keeps Modularizing

```
2020: Monolithic L1 (Ethereum does everything)

2024: Modular stack
      ├── Execution: L2 rollups
      ├── Settlement: L1
      ├── Data availability: Blobs, Celestia
      └── Sequencing: Shared sequencers
```

## The Dependency Position

### What L2s Enable

```
              ┌─────────────────────────────────────┐
              │       NEW POSSIBILITIES             │
              │  (On-chain gaming, social, micro-  │
              │   payments, high-frequency DeFi)   │
              └─────────────────┬───────────────────┘
                                │
                                ▼
              ┌─────────────────────────────────────┐
              │          L2 ROLLUPS                 │
              │  (Cheap execution, fast finality)  │
              └─────────────────┬───────────────────┘
                                │
                                ▼
              ┌─────────────────────────────────────┐
              │         DATA AVAILABILITY           │
              │  (Blobs, Celestia, EigenDA)        │
              └─────────────────┬───────────────────┘
                                │
                                ▼
              ┌─────────────────────────────────────┐
              │           ETHEREUM L1               │
              │  (Security, settlement, ordering)  │
              └─────────────────────────────────────┘
```

### What Depends on L2s

- **Low-value transactions**: Payments, gaming, social
- **High-frequency operations**: Orderbook DEXs, perpetuals
- **New user segments**: Users priced out of L1
- **New use cases**: Fully on-chain games, real-time apps

## Conclusions

L2 scaling has evolved through distinct eras:

1. **Era 0 (2017-2019)**: Plasma and state channels—learned that data availability is critical
2. **Era 1 (2020-2021)**: Optimistic rollups proved the model works
3. **Era 2 (2022-2024)**: ZK rollups matured, proving costs dropped
4. **Era 3 (2024+)**: Blobs made L2s economically dominant

**For developers:**
- L2s are EVM-compatible—your code works unchanged
- Choose L2 based on ecosystem, not just technology
- Design for cross-L2 world (bridging, messaging)
- Account for finality differences in UX

The future is multi-L2. Users won't know which rollup they're on—wallets will abstract it away. But builders need to understand the stack to make good decisions about where to deploy and how to design cross-chain experiences.

The EVM is the constant across L1, L2, and beyond.
