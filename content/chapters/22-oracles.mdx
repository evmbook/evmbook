---
title: "Oracles & Data Feeds"
description: The oracle landscape from Chainlink to Chronicle, and when to use each
chapter: 22
---

# Oracles & Data Feeds

Smart contracts are deterministic: given the same inputs, every node produces the same outputs. This determinism enables consensus but creates a fundamental limitation—contracts cannot access external data. They can't fetch prices, check weather, or verify real-world events.

Oracles bridge this gap, bringing off-chain data on-chain in ways contracts can consume. This chapter examines how oracle solutions evolved, compares the major providers, and helps you choose the right oracle for your use case.

## The Oracle Problem

Why can't smart contracts just make HTTP requests?

```solidity
// This is IMPOSSIBLE
function getPrice() public returns (uint256) {
    // Contracts cannot do this
    return http.get("https://api.exchange.com/eth-price");
}
```

If contracts could fetch external data arbitrarily:
1. Different nodes might get different responses (network latency, API changes)
2. Consensus would fail—nodes couldn't agree on state
3. External APIs could manipulate contract behavior

The oracle problem: **How do we bring external data on-chain in a trustworthy, decentralized manner?**

Every oracle solution makes tradeoffs between:
- **Decentralization**: How many independent parties provide data?
- **Latency**: How quickly does data update?
- **Cost**: How much does each update cost?
- **Coverage**: What data feeds are available?

## Era 1: Centralized Oracles (2016-2017)

### The Simple Solution

Early DeFi used simple trusted oracles: a single party posts data on-chain.

```solidity
contract SimpleOracle {
    address public owner;
    uint256 public price;
    uint256 public lastUpdated;

    function updatePrice(uint256 newPrice) external {
        require(msg.sender == owner, "Not authorized");
        price = newPrice;
        lastUpdated = block.timestamp;
    }
}
```

**The Problem**: Single points of failure. If the oracle operator:
- Goes offline → stale data
- Gets hacked → manipulated data
- Acts maliciously → theft

MakerDAO's original oracles used a 2-of-3 multisig of trusted parties. Better than one, but still centralized.

## Era 2: Decentralized Oracle Networks (2017-2020)

### Chainlink: The Dominant Solution

Chainlink launched with a decentralized oracle network: multiple independent node operators fetch data, aggregate it, and post consensus values on-chain.

```
Data Flow:

External APIs → Node Operators → Aggregation Contract → Your Contract
   (many)          (many)           (on-chain)

Price Sources:        Chainlink Nodes:       Aggregator:
- Binance             - Node A: $2000.50     Median: $2001.00
- Coinbase            - Node B: $2001.00     → Posted on-chain
- Kraken              - Node C: $2001.50
- etc.                - etc.
```

```solidity
// Chainlink Price Feed integration
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

contract PriceConsumer {
    AggregatorV3Interface internal priceFeed;

    constructor() {
        // ETH/USD on Ethereum Mainnet
        priceFeed = AggregatorV3Interface(
            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419
        );
    }

    function getLatestPrice() public view returns (int256, uint256) {
        (
            uint80 roundId,
            int256 price,
            uint256 startedAt,
            uint256 updatedAt,
            uint80 answeredInRound
        ) = priceFeed.latestRoundData();

        // Validation checks
        require(price > 0, "Invalid price");
        require(updatedAt > 0, "Round not complete");
        require(block.timestamp - updatedAt < 3600, "Stale price");

        return (price, updatedAt); // price has 8 decimals for USD pairs
    }
}
```

**Chainlink's Advantages:**
- Battle-tested (secures $75B+ TVL)
- Wide coverage (hundreds of price feeds)
- Multi-chain support
- Additional services: VRF (randomness), Automation, CCIP (cross-chain)

**Chainlink's Tradeoffs:**
- Cost: Updates require gas, passed to feed sponsors
- Latency: Updates on deviation or heartbeat (not every block)
- Centralization concerns: Chainlink Labs controls node allowlisting

### Using Chainlink VRF

Verifiable Random Function for provably fair randomness:

```solidity
import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";

contract RandomGame is VRFConsumerBaseV2 {
    uint256[] public randomResults;

    function requestRandomWords() external returns (uint256 requestId) {
        requestId = COORDINATOR.requestRandomWords(
            keyHash,
            subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );
    }

    function fulfillRandomWords(
        uint256 requestId,
        uint256[] memory randomWords
    ) internal override {
        randomResults = randomWords;
        // Provably fair: VRF proof verified on-chain
    }
}
```

## Era 3: Specialized Oracle Designs (2020-Present)

As DeFi matured, specialized oracles emerged for different use cases.

### Uniswap TWAP: On-Chain Price Oracle

Uniswap V2 introduced Time-Weighted Average Prices (TWAP): prices derived from on-chain DEX data, resistant to single-block manipulation.

```solidity
// Uniswap V2 accumulates price * time
// TWAP = (priceCumulativeEnd - priceCumulativeStart) / timeElapsed

contract TWAPOracle {
    IUniswapV2Pair public pair;
    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint32 public blockTimestampLast;
    uint256 public price0Average;
    uint256 public price1Average;

    uint256 public constant PERIOD = 24 hours;

    function update() external {
        (
            uint256 price0Cumulative,
            uint256 price1Cumulative,
            uint32 blockTimestamp
        ) = UniswapV2OracleLibrary.currentCumulativePrices(address(pair));

        uint32 timeElapsed = blockTimestamp - blockTimestampLast;

        require(timeElapsed >= PERIOD, "Period not elapsed");

        // Calculate average price over period
        price0Average = (price0Cumulative - price0CumulativeLast) / timeElapsed;
        price1Average = (price1Cumulative - price1CumulativeLast) / timeElapsed;

        price0CumulativeLast = price0Cumulative;
        price1CumulativeLast = price1Cumulative;
        blockTimestampLast = blockTimestamp;
    }
}
```

**TWAP Advantages:**
- No external dependencies—fully on-chain
- Permissionless—any token pair with liquidity
- Manipulation-resistant over long periods

**TWAP Limitations:**
- Requires sufficient liquidity (thin pools are manipulable)
- Lagging indicator (averages historical prices)
- Must be actively maintained (someone calls `update()`)

### Chronicle: Gas-Efficient Scribe Architecture

Chronicle emerged from MakerDAO's oracle infrastructure, redesigned for gas efficiency.

```solidity
// Chronicle's Scribe architecture
// Multiple validators sign off-chain, single on-chain verification

interface IChronicle {
    function read() external view returns (uint256 value);
    function readWithAge() external view returns (uint256 value, uint256 age);
}

contract ChronicleConsumer {
    IChronicle public chronicle;

    function getPrice() external view returns (uint256) {
        (uint256 price, uint256 age) = chronicle.readWithAge();
        require(block.timestamp - age < 3600, "Stale price");
        return price;
    }
}
```

**How Scribe Works:**
1. Validators sign price updates off-chain (Schnorr signatures)
2. Single aggregated signature posted on-chain
3. Verification cost: ~O(1) regardless of validator count

**Chronicle Advantages:**
- 60%+ gas savings vs Chainlink
- MakerDAO pedigree (powers DAI)
- Growing feed coverage

**Chronicle Limitations:**
- Smaller network than Chainlink
- Fewer chains supported
- Newer, less battle-tested

### RedStone: Modular On-Demand Oracles

RedStone takes a different approach: data is pushed with transactions rather than stored on-chain.

```solidity
// RedStone injects price data into calldata
// Verified at execution time, not pre-stored

import "@redstone-finance/evm-connector/contracts/data-services/MainDemoConsumerBase.sol";

contract RedStoneConsumer is MainDemoConsumerBase {
    function getEthPrice() public view returns (uint256) {
        // Price data extracted from calldata
        // Signed by RedStone data providers
        return getOracleNumericValueFromTxMsg(bytes32("ETH"));
    }
}
```

**RedStone Advantages:**
- No storage costs (data in calldata)
- Fresh prices every transaction
- Easy deployment to new chains

**RedStone Limitations:**
- Requires modified transaction flow
- Frontend must include price data
- Less intuitive integration pattern

### Pyth Network: High-Frequency Updates

Pyth originated from Solana, offering sub-second price updates for trading applications.

```solidity
import "@pythnetwork/pyth-sdk-solidity/IPyth.sol";

contract PythConsumer {
    IPyth public pyth;

    function updateAndGetPrice(
        bytes[] calldata priceUpdateData,
        bytes32 priceId
    ) external payable returns (int64 price) {
        // User pays for update
        uint256 fee = pyth.getUpdateFee(priceUpdateData);
        pyth.updatePriceFeeds{value: fee}(priceUpdateData);

        // Get updated price
        PythStructs.Price memory priceData = pyth.getPrice(priceId);
        return priceData.price;
    }
}
```

**Pyth Advantages:**
- Sub-second latency (pull-based updates)
- Wide asset coverage (crypto, forex, commodities)
- Cross-chain from inception

**Pyth Limitations:**
- Pull model requires user to update first
- Higher integration complexity
- Newer network, building trust

### Tellor: Permissionless Reporting

Tellor allows anyone to submit data, with staking and disputes for accuracy.

```solidity
interface ITellor {
    function getDataBefore(
        bytes32 queryId,
        uint256 timestamp
    ) external view returns (
        bool ifRetrieve,
        bytes memory value,
        uint256 timestampRetrieved
    );
}

contract TellorConsumer {
    ITellor public tellor;

    function getPrice(bytes32 queryId) external view returns (uint256) {
        // Get most recent value before now
        (bool success, bytes memory value, uint256 timestamp) =
            tellor.getDataBefore(queryId, block.timestamp);

        require(success, "No data");
        require(block.timestamp - timestamp < 86400, "Stale data");

        return abi.decode(value, (uint256));
    }
}
```

**Tellor Advantages:**
- Truly permissionless—anyone can report
- Censorship-resistant
- Flexible query system (any data type)

**Tellor Limitations:**
- Slower updates (reporter must stake, wait period)
- Smaller reporter network
- Dispute resolution takes time

### API3: First-Party Oracles

API3 connects data providers directly to blockchains—first-party oracles rather than third-party aggregators.

```solidity
interface IApi3ReaderProxy {
    function read() external view returns (int224 value, uint32 timestamp);
}

contract API3Consumer {
    IApi3ReaderProxy public proxy;

    function getPrice() external view returns (int224) {
        (int224 value, uint32 timestamp) = proxy.read();
        require(block.timestamp - timestamp < 86400, "Stale");
        return value;
    }
}
```

**API3 Advantages:**
- Data directly from source (no middleman)
- dAPI marketplace for standardized feeds
- OEV (Oracle Extractable Value) capture

**API3 Limitations:**
- Depends on data provider reliability
- Smaller ecosystem than Chainlink
- Coverage gaps for some assets

### UMA: Optimistic Oracle

UMA's optimistic oracle assumes data is correct unless disputed—ideal for long-tail data needs.

```solidity
interface OptimisticOracleV2 {
    function requestPrice(
        bytes32 identifier,
        uint256 timestamp,
        bytes memory ancillaryData,
        IERC20 currency,
        uint256 reward
    ) external returns (uint256 totalBond);

    function settleAndGetPrice(
        bytes32 identifier,
        uint256 timestamp,
        bytes memory ancillaryData
    ) external returns (int256);
}

// Flow:
// 1. Request price (any question in natural language)
// 2. Proposer posts answer + bond
// 3. 2-hour dispute window
// 4. If no dispute, answer finalized
// 5. If disputed, UMA token holders vote
```

**UMA Advantages:**
- Any question answerable (not just prices)
- Low cost for undisputed queries
- Powers Polymarket resolution

**UMA Limitations:**
- Hours to finalize (dispute window)
- Not suitable for real-time prices
- Relies on token holder voting for disputes

## The Oracle Landscape (2026)

| Oracle | Best For | Latency | Cost | Decentralization |
|--------|----------|---------|------|------------------|
| **Chainlink** | Default choice, broad coverage | ~1 min heartbeat | Medium | High (permissioned) |
| **Chronicle** | Gas-sensitive DeFi | ~1 min | Low | Medium |
| **Pyth** | High-frequency trading | Sub-second | Low (pull) | Medium |
| **RedStone** | New chains, custom feeds | Per-transaction | Very Low | Medium |
| **Tellor** | Censorship resistance | Minutes-hours | Low | Very High |
| **API3** | First-party data needs | Varies | Medium | Medium |
| **UMA** | Prediction markets, disputes | Hours | Low | High |
| **Uniswap TWAP** | On-chain, permissionless | Period-based | None | Maximum |

### Decision Matrix

```
Need real-time prices for trading?
  → Pyth or Chainlink

Building a lending protocol?
  → Chainlink (default) or Chronicle (gas savings)

Deploying to new/small chain?
  → RedStone (easy deployment) or custom TWAP

Need censorship resistance?
  → Tellor

Resolving prediction market outcomes?
  → UMA

Want data directly from source?
  → API3

Need on-chain only, no external deps?
  → Uniswap TWAP
```

## Oracle Security

### Common Attack Vectors

**1. Flash Loan Price Manipulation**

```solidity
// VULNERABLE: Spot price can be manipulated
function getPrice() public view returns (uint256) {
    (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();
    return reserve1 * 1e18 / reserve0; // Flash loan attackable!
}

// SAFE: Use TWAP or external oracle
function getPrice() public view returns (uint256) {
    (, int256 price, , , ) = chainlink.latestRoundData();
    return uint256(price);
}
```

**2. Stale Data**

```solidity
// Always check freshness
function getPrice() public view returns (uint256) {
    (, int256 price, , uint256 updatedAt, ) = feed.latestRoundData();

    require(price > 0, "Invalid price");
    require(block.timestamp - updatedAt < MAX_STALENESS, "Stale price");

    return uint256(price);
}
```

**3. Round Completeness**

```solidity
// For Chainlink, verify round is complete
(
    uint80 roundId,
    int256 price,
    ,
    uint256 updatedAt,
    uint80 answeredInRound
) = feed.latestRoundData();

require(answeredInRound >= roundId, "Round not complete");
```

**4. Price Bounds**

```solidity
// Sanity check price ranges
require(price > MIN_PRICE && price < MAX_PRICE, "Price out of bounds");
```

### Best Practices

1. **Use multiple oracles** for critical applications
2. **Always validate** freshness, bounds, and completeness
3. **Have fallbacks** for oracle failures
4. **Monitor** oracle health off-chain
5. **Consider circuit breakers** for extreme price movements

```solidity
contract RobustPriceConsumer {
    AggregatorV3Interface public primaryOracle;
    AggregatorV3Interface public fallbackOracle;
    uint256 public lastKnownPrice;

    function getPrice() public returns (uint256) {
        // Try primary
        try primaryOracle.latestRoundData() returns (
            uint80, int256 price, uint256, uint256 updatedAt, uint80
        ) {
            if (price > 0 && block.timestamp - updatedAt < 3600) {
                lastKnownPrice = uint256(price);
                return uint256(price);
            }
        } catch {}

        // Try fallback
        try fallbackOracle.latestRoundData() returns (
            uint80, int256 price, uint256, uint256 updatedAt, uint80
        ) {
            if (price > 0 && block.timestamp - updatedAt < 3600) {
                lastKnownPrice = uint256(price);
                return uint256(price);
            }
        } catch {}

        // Return last known (with caution)
        require(lastKnownPrice > 0, "No valid price");
        return lastKnownPrice;
    }
}
```

## The Dependency Position

```
                    ┌─────────────────────────────────────┐
                    │          DeFi PROTOCOLS             │
                    │   Lending, DEXs, Derivatives        │
                    └─────────────────┬───────────────────┘
                                      │
        ┌─────────────────────────────┼─────────────────────────────┐
        │                             │                             │
        ▼                             ▼                             ▼
┌───────────────┐           ┌─────────────────┐           ┌─────────────────┐
│   LENDING     │           │   DERIVATIVES   │           │   PREDICTION    │
│ Liquidation   │           │ Settlement      │           │    MARKETS      │
│ triggers      │           │ prices          │           │   Resolution    │
└───────┬───────┘           └────────┬────────┘           └────────┬────────┘
        │                            │                             │
        └────────────────────────────┼─────────────────────────────┘
                                     │
                                     ▼
                    ┌────────────────────────────────────┐
                    │            ORACLES                 │
                    │  Chainlink, Chronicle, Pyth, etc.  │
                    └─────────────────┬──────────────────┘
                                      │
              ┌───────────────────────┼───────────────────────┐
              │                       │                       │
              ▼                       ▼                       ▼
       ┌───────────┐           ┌───────────┐           ┌───────────┐
       │  EXTERNAL │           │   ON-CHAIN│           │  TOKEN    │
       │   APIS    │           │   DATA    │           │  STAKES   │
       │  Exchanges│           │   TWAP    │           │  Reporter │
       └───────────┘           └───────────┘           └───────────┘
```

## What We Learned

**1. No perfect oracle exists.** Every solution trades off decentralization, latency, cost, and coverage. Choose based on your requirements.

**2. Chainlink remains the default.** For most use cases, Chainlink's coverage and battle-testing make it the safe choice. Consider alternatives for specific needs.

**3. Gas efficiency matters.** Chronicle and RedStone demonstrate that oracle costs can be dramatically reduced without sacrificing security.

**4. Pull vs push models.** Pyth and RedStone's pull model shifts costs to users but provides fresher data. Push model (Chainlink) is simpler but more expensive.

**5. Validation is non-negotiable.** Every oracle integration needs freshness checks, bounds validation, and fallback handling.

The oracle landscape continues evolving. ZK-proven data feeds, AI-verified information, and cross-chain oracle networks are emerging. But the fundamental challenge remains: trustworthy bridges between on-chain determinism and off-chain reality.
