---
title: "Governance & DAOs"
description: From multisigs to on-chain voting, timelocks to veToken governance
chapter: 18
---

# Governance & DAOs

"Decentralized" protocols still need to make decisions: upgrade contracts, adjust parameters, allocate treasury funds. Governance is how those decisions get made—and who gets to make them.

This chapter traces the evolution from simple multisigs to sophisticated on-chain governance systems. We'll examine the OpenZeppelin Governor standard in detail, explore veToken governance models, and discuss the practical realities of running a DAO in 2026.

## The Governance Problem

Smart contracts are immutable by default. But protocols need to evolve:

- **Security patches**: Vulnerabilities require fixes
- **Parameter tuning**: Interest rates, fees, and thresholds need adjustment
- **Feature additions**: New collateral types, new markets, new functionality
- **Treasury management**: Protocol-owned funds require allocation decisions

The question isn't whether governance exists—it's whether it's transparent. Every "decentralized" protocol has some upgrade mechanism. The honest ones make it visible.

## Era 1: Trusted Multisigs (2016-2019)

### The Gnosis Safe Model

Early DeFi protocols used multisignature wallets for governance: N-of-M trusted parties must approve transactions.

```solidity
// Simplified multisig pattern
contract Multisig {
    mapping(address => bool) public owners;
    uint256 public required;

    struct Transaction {
        address to;
        uint256 value;
        bytes data;
        bool executed;
        uint256 confirmations;
    }

    Transaction[] public transactions;
    mapping(uint256 => mapping(address => bool)) public confirmed;

    function submitTransaction(address to, uint256 value, bytes calldata data) external onlyOwner {
        transactions.push(Transaction(to, value, data, false, 0));
    }

    function confirmTransaction(uint256 txId) external onlyOwner {
        require(!confirmed[txId][msg.sender], "Already confirmed");
        confirmed[txId][msg.sender] = true;
        transactions[txId].confirmations++;

        if (transactions[txId].confirmations >= required) {
            executeTransaction(txId);
        }
    }

    function executeTransaction(uint256 txId) internal {
        Transaction storage txn = transactions[txId];
        require(!txn.executed, "Already executed");
        txn.executed = true;
        (bool success,) = txn.to.call{value: txn.value}(txn.data);
        require(success, "Execution failed");
    }
}
```

**Common Configurations:**

- **3-of-5**: Requires 3 team members to agree
- **4-of-7**: Higher threshold for larger protocols
- **2-of-3**: Small projects, faster decisions

**The Problems:**

1. **Trust concentration**: Users must trust the multisig signers
2. **Opaque decision-making**: Discussions happen off-chain
3. **No stakeholder input**: Token holders have no formal voice
4. **Key management risk**: Lost keys can freeze protocol

<Callout type="warning" title="Multisig Reality Check">
Many "decentralized" protocols remain governed by small multisigs. This isn't inherently wrong—but claiming decentralization while a 3-of-5 controls everything is misleading. Know your protocol's actual governance structure.
</Callout>

## Era 2: On-Chain Governance (2020)

### Compound Governor: The Standard

Compound Governor (2020) introduced formal on-chain voting: token holders propose and vote on protocol changes.

```solidity
// Core Governor flow
// 1. Create proposal
// 2. Wait for voting delay (review period)
// 3. Voting period opens
// 4. If quorum met and votes pass, queue for execution
// 5. Timelock delay
// 6. Execute

function propose(
    address[] memory targets,
    uint256[] memory values,
    string[] memory signatures,
    bytes[] memory calldatas,
    string memory description
) public returns (uint256) {
    // Proposer must have enough voting power
    require(
        getVotes(msg.sender, block.number - 1) >= proposalThreshold(),
        "Below proposal threshold"
    );

    uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));

    proposals[proposalId] = Proposal({
        proposer: msg.sender,
        eta: 0,
        targets: targets,
        values: values,
        signatures: signatures,
        calldatas: calldatas,
        startBlock: block.number + votingDelay(),
        endBlock: block.number + votingDelay() + votingPeriod(),
        forVotes: 0,
        againstVotes: 0,
        abstainVotes: 0,
        canceled: false,
        executed: false
    });

    return proposalId;
}
```

### The Voting Process

```
Proposal Lifecycle:

Day 0: Proposal created
       ├── Proposer needs >1% of tokens
       └── Proposal details visible on-chain

Day 0-2: Voting delay
         └── Community reviews, discusses off-chain

Day 2-9: Voting period (7 days typical)
         ├── Token holders cast votes (For/Against/Abstain)
         └── Votes weighted by token balance

Day 9: Voting ends
       ├── Quorum check (e.g., 4% of total supply voted)
       └── Majority check (For > Against)

Day 9-11: Timelock (2 days typical)
          └── Users can exit if they disagree

Day 11: Execution
        └── Proposal actions execute on-chain
```

### Timelocks: The Safety Valve

Timelocks delay execution after votes pass, giving users time to react:

```solidity
// Timelock controller
contract Timelock {
    uint256 public constant MINIMUM_DELAY = 2 days;
    uint256 public constant MAXIMUM_DELAY = 30 days;

    mapping(bytes32 => bool) public queuedTransactions;

    function queueTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) public onlyAdmin returns (bytes32) {
        require(eta >= block.timestamp + delay, "ETA too soon");

        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));
        queuedTransactions[txHash] = true;

        return txHash;
    }

    function executeTransaction(
        address target,
        uint256 value,
        string memory signature,
        bytes memory data,
        uint256 eta
    ) public onlyAdmin returns (bytes memory) {
        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));

        require(queuedTransactions[txHash], "Not queued");
        require(block.timestamp >= eta, "Too early");
        require(block.timestamp <= eta + GRACE_PERIOD, "Stale");

        queuedTransactions[txHash] = false;

        bytes memory callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);
        (bool success, bytes memory returnData) = target.call{value: value}(callData);
        require(success, "Execution failed");

        return returnData;
    }
}
```

**Why Timelocks Matter:**

If governance passes a malicious proposal (hack, bribery, mistake), users have time to:
- Withdraw funds from the protocol
- Sell governance tokens
- Rally opposition to cancel

Without timelocks, a governance attack can drain a protocol instantly.

## Era 3: OpenZeppelin Governor (2021-Present)

### The Modular Standard

OpenZeppelin Governor became the standard implementation, used by Uniswap, ENS, Gitcoin, and hundreds of other protocols.

```solidity
// OpenZeppelin Governor with common extensions
import "@openzeppelin/contracts/governance/Governor.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol";

contract MyGovernor is
    Governor,
    GovernorSettings,
    GovernorCountingSimple,
    GovernorVotes,
    GovernorVotesQuorumFraction,
    GovernorTimelockControl
{
    constructor(
        IVotes _token,
        TimelockController _timelock
    )
        Governor("MyGovernor")
        GovernorSettings(
            1 days,    // voting delay
            1 weeks,   // voting period
            1000e18    // proposal threshold (1000 tokens)
        )
        GovernorVotes(_token)
        GovernorVotesQuorumFraction(4)  // 4% quorum
        GovernorTimelockControl(_timelock)
    {}

    // Override functions as needed...
}
```

### Extension Modules

| Extension | Purpose |
|-----------|---------|
| `GovernorSettings` | Configurable voting delay, period, threshold |
| `GovernorCountingSimple` | For/Against/Abstain vote counting |
| `GovernorVotes` | Integrates with ERC20Votes tokens |
| `GovernorVotesQuorumFraction` | Quorum as percentage of supply |
| `GovernorTimelockControl` | Timelock integration |
| `GovernorPreventLateQuorum` | Extends voting if quorum reached late |

### ERC20Votes: Governance Tokens

Governance tokens need snapshot capability—votes should be counted based on balance at proposal creation, not current balance (prevents vote buying after seeing proposal).

```solidity
// ERC20Votes extension
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";

contract GovernanceToken is ERC20, ERC20Votes {
    constructor() ERC20("Governance Token", "GOV") ERC20Permit("Governance Token") {}

    // Checkpointing: stores balance at each block
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20, ERC20Votes) {
        super._afterTokenTransfer(from, to, amount);
    }

    // Get votes at a specific block number
    function getVotes(address account) public view override returns (uint256) {
        return super.getVotes(account);
    }

    function getPastVotes(address account, uint256 blockNumber) public view override returns (uint256) {
        return super.getPastVotes(account, blockNumber);
    }
}
```

### Delegation

Token holders can delegate voting power without transferring tokens:

```solidity
// Delegation pattern
function delegate(address delegatee) public virtual {
    _delegate(msg.sender, delegatee);
}

function _delegate(address delegator, address delegatee) internal virtual {
    address currentDelegate = delegates(delegator);
    uint256 delegatorBalance = balanceOf(delegator);

    _delegates[delegator] = delegatee;

    // Move voting power from old delegate to new
    _moveVotingPower(currentDelegate, delegatee, delegatorBalance);
}

// Self-delegation is common for active voters
// Delegation to representatives enables liquid democracy
```

**Why Delegation Matters:**

- **Engagement**: Most token holders don't vote; delegation lets them participate passively
- **Expertise**: Technical proposals benefit from informed delegates
- **Quorum**: Concentrated voting power helps reach quorum

## Era 4: veToken Governance (2020-Present)

### The Curve Model

Curve introduced **vote-escrowed tokens (veCRV)**: lock CRV to receive voting power, with longer locks granting more power.

```solidity
// Simplified veToken mechanics
function createLock(uint256 amount, uint256 unlockTime) external {
    require(unlockTime > block.timestamp, "Unlock in past");
    require(unlockTime <= block.timestamp + MAX_LOCK_TIME, "Lock too long");

    // Transfer and lock tokens
    CRV.transferFrom(msg.sender, address(this), amount);

    // Voting power = amount * (timeRemaining / maxLockTime)
    // 4 year lock = 1:1 voting power
    // 1 year lock = 0.25 voting power
    uint256 votingPower = amount * (unlockTime - block.timestamp) / MAX_LOCK_TIME;

    locked[msg.sender] = LockedBalance({
        amount: amount,
        end: unlockTime
    });

    // Voting power decays linearly until unlock
}
```

**Key Properties:**

1. **Time preference**: Longer commitment = more influence
2. **Decay**: Voting power decreases as unlock approaches, incentivizing relocks
3. **Non-transferable**: veTokens can't be sold, preventing vote markets

### The Gauge System

veToken holders vote on "gauges"—allocation of protocol emissions:

```solidity
// Gauge voting (simplified)
function voteForGaugeWeights(address gauge, uint256 weight) external {
    require(isGauge[gauge], "Invalid gauge");
    require(weight <= 10000, "Weight too high"); // Max 100% of user's power

    uint256 userVotingPower = votingPower(msg.sender);
    uint256 allocatedPower = weight * userVotingPower / 10000;

    // Record vote
    gaugeVotes[gauge] += allocatedPower;
    userGaugeVotes[msg.sender][gauge] = allocatedPower;

    // Total weight determines emission allocation
}
```

**The Curve Wars:**

Protocols competed to accumulate veCRV to direct CRV emissions to their pools:
- **Convex Finance**: Aggregated veCRV, became largest holder
- **Yearn**: Accumulated veCRV for strategy optimization
- **Bribes**: vlCVX (Convex's liquid wrapper) holders receive bribes for gauge votes

### ve(3,3): The Evolution

Andre Cronje's Solidly combined Curve's ve-model with Olympus DAO's (3,3) game theory:

```solidity
// ve(3,3) additions to standard veToken

// 1. veToken holders receive trading fees from pools they vote for
function claimFees(address gauge) external {
    uint256 userShare = gaugeVotes[msg.sender][gauge] / totalGaugeVotes[gauge];
    uint256 feeAmount = accumulatedFees[gauge] * userShare;
    feeToken.transfer(msg.sender, feeAmount);
}

// 2. Anti-dilution: veToken holders receive proportional emissions
function claimRebase() external {
    uint256 userShare = votingPower(msg.sender) / totalVotingPower;
    uint256 rebaseAmount = weeklyEmissions * userShare;
    token.mint(msg.sender, rebaseAmount);
}

// 3. Bribes: external rewards for voting on specific gauges
function depositBribe(address gauge, address token, uint256 amount) external {
    IERC20(token).transferFrom(msg.sender, address(this), amount);
    bribes[gauge][token] += amount;
}
```

**Velodrome/Aerodrome Success:**

Velodrome (Optimism) and Aerodrome (Base) refined ve(3,3):
- Simplified UI for voting and bribe claiming
- Weekly epochs with clear incentives
- Strong ecosystem partnerships

## Governance in Practice

### Common Governance Attacks

| Attack | Mechanism | Defense |
|--------|-----------|---------|
| **Flash loan voting** | Borrow tokens, vote, return | Snapshot at proposal creation |
| **Vote buying** | Pay holders for votes | veToken (non-transferable) |
| **Governance extraction** | Vote to drain treasury | Timelocks, multisig veto |
| **Proposal spam** | Flood with malicious proposals | Proposal threshold |
| **Last-minute voting** | Large vote at end | Vote extension mechanisms |

### Progressive Decentralization

Most protocols start centralized and decentralize over time:

```
Stage 1: Team multisig (3-of-5)
         └── Fast decisions, trusted team

Stage 2: Multisig + community input
         └── Forum discussions, temperature checks

Stage 3: Token governance with guardian multisig
         └── On-chain votes, multisig can veto

Stage 4: Full token governance with timelock
         └── Community controls, long timelocks

Stage 5: Immutable or minimal governance
         └── Parameters hardcoded or very limited scope
```

**Honest Communication:**

```solidity
/// @title MyProtocol
/// @dev GOVERNANCE STATUS:
/// - Current: 4-of-7 team multisig with 48h timelock
/// - Guardian: Multisig can pause and cancel proposals
/// - Path: Token governance planned Q3 2026
/// - Scope: Multisig controls upgrades, fees, and treasury
contract MyProtocol {
    // Document actual trust assumptions
}
```

### Real-World Governance Failures

**Beanstalk (April 2022):**
- Attacker flash-loaned governance tokens
- Passed malicious proposal instantly (no voting delay)
- Drained $182M in one transaction
- **Lesson**: Voting delay + snapshots are essential

**Build Finance (February 2022):**
- Attacker accumulated majority of governance tokens
- Passed proposal to transfer treasury
- "Legal" governance attack—technically valid votes
- **Lesson**: Timelocks give users time to exit

## Building Governance

### Minimal Governor Setup

```solidity
// 1. Deploy governance token with ERC20Votes
GovernanceToken token = new GovernanceToken();

// 2. Deploy timelock
address[] memory proposers = new address[](0);
address[] memory executors = new address[](1);
executors[0] = address(0); // Anyone can execute after timelock

TimelockController timelock = new TimelockController(
    2 days,     // Minimum delay
    proposers,  // Governor will be added
    executors,
    address(0)  // No admin
);

// 3. Deploy governor
MyGovernor governor = new MyGovernor(token, timelock);

// 4. Grant roles
timelock.grantRole(timelock.PROPOSER_ROLE(), address(governor));
timelock.grantRole(timelock.CANCELLER_ROLE(), address(governor));

// 5. Transfer protocol ownership to timelock
protocol.transferOwnership(address(timelock));
```

### Parameter Recommendations

| Parameter | Conservative | Moderate | Aggressive |
|-----------|--------------|----------|------------|
| Voting delay | 2 days | 1 day | 1 block |
| Voting period | 7 days | 5 days | 3 days |
| Proposal threshold | 1% of supply | 0.5% | 0.1% |
| Quorum | 10% | 4% | 2% |
| Timelock | 7 days | 2 days | 1 day |

### Off-Chain Components

On-chain governance needs off-chain infrastructure:

- **Discussion forums**: Discourse, Commonwealth
- **Voting interfaces**: Tally, Snapshot (for signaling)
- **Delegation platforms**: Agora, Karma
- **Analytics**: Track participation, delegate performance

## What We Learned

**1. Governance is unavoidable.** Even "immutable" protocols have upgrade mechanisms. The question is transparency.

**2. Security first.** Voting delays, snapshots, and timelocks aren't bureaucracy—they prevent attacks.

**3. Participation is hard.** Most token holders don't vote. Delegation helps but creates its own power concentrations.

**4. Incentives matter.** veToken models align holders with long-term protocol success better than liquid governance tokens.

**5. Progressive decentralization works.** Starting with multisig and moving to token governance as the protocol matures is a legitimate path—if communicated honestly.

Governance will continue evolving. Optimistic governance (assume proposals pass unless vetoed), futarchy (prediction market-based decisions), and quadratic voting (reduce whale dominance) are active areas of experimentation. But the core challenge remains: how do decentralized organizations make decisions effectively while remaining decentralized?
