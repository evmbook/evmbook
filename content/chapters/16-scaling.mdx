---
title: Scaling Solutions
description: Layer 2s, rollups, and increasing blockchain throughput
chapter: 16
---

# Scaling Solutions

Blockchain scalability is the challenge of increasing transaction throughput while maintaining decentralization and security. The base layer of Ethereum processes ~15-30 transactions per second. Scaling solutions aim to increase this by orders of magnitude.

This chapter covers the major scaling approaches, with a focus on Layer 2 solutions.

## The Scalability Trilemma

Blockchains face tradeoffs between three properties:

```
                    Decentralization
                          ▲
                         / \
                        /   \
                       /     \
                      /       \
                     /_________\
              Security ◀─────────▶ Scalability
```

- **Decentralization** — Many independent validators
- **Security** — Resistance to attacks
- **Scalability** — High transaction throughput

Traditional databases are scalable but centralized. Bitcoin is decentralized but limited throughput. The goal is to improve scalability without sacrificing the other two.

## Scaling Approaches

### Layer 1 Scaling

Improving the base blockchain:
- Larger blocks (increases hardware requirements)
- Sharding (splits the network)
- Better consensus (more efficient validation)

### Layer 2 Scaling

Building on top of the base layer:
- Rollups (execute off-chain, post data on-chain)
- State channels (off-chain transactions, on-chain settlement)
- Sidechains (separate chains with bridges)

### Off-Chain Scaling

Moving computation entirely off-chain:
- Validiums (off-chain data and computation)
- Plasma (off-chain with on-chain exits)

## Rollups

Rollups are the dominant Layer 2 scaling solution. They execute transactions off-chain but post transaction data to the main chain.

### How Rollups Work

1. Users submit transactions to the rollup
2. Rollup operator batches transactions
3. Batch is executed off-chain
4. Compressed data posted to L1
5. State root updated on L1

```
┌─────────────────────────────────────────────────────────────┐
│                        Layer 2 Rollup                        │
│  ┌────────┐  ┌────────┐  ┌────────┐                         │
│  │  Tx 1  │  │  Tx 2  │  │  Tx 3  │  ... (1000s of txs)    │
│  └────────┘  └────────┘  └────────┘                         │
│                    │                                         │
│                    ▼                                         │
│              ┌──────────────────┐                           │
│              │   Batch + Proof  │                           │
│              └────────┬─────────┘                           │
│                       │                                      │
└───────────────────────┼──────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│                     Layer 1 (Ethereum)                        │
│              ┌──────────────────────────┐                     │
│              │  State Root + Call Data  │                     │
│              └──────────────────────────┘                     │
└───────────────────────────────────────────────────────────────┘
```

### Optimistic Rollups

Assume transactions are valid, but allow challenges:

```solidity
// Simplified optimistic rollup contract
contract OptimisticRollup {
    bytes32 public stateRoot;
    uint256 public constant CHALLENGE_PERIOD = 7 days;

    struct Batch {
        bytes32 newStateRoot;
        uint256 timestamp;
        bool finalized;
    }

    mapping(uint256 => Batch) public batches;

    function submitBatch(bytes32 newStateRoot, bytes calldata txData) external {
        // Anyone can submit a batch
        batches[batchId] = Batch(newStateRoot, block.timestamp, false);
    }

    function challengeBatch(uint256 batchId, bytes calldata fraudProof) external {
        Batch storage batch = batches[batchId];
        require(block.timestamp < batch.timestamp + CHALLENGE_PERIOD);

        // Verify fraud proof
        if (verifyFraud(fraudProof)) {
            // Revert batch, slash operator
            delete batches[batchId];
        }
    }

    function finalizeBatch(uint256 batchId) external {
        Batch storage batch = batches[batchId];
        require(block.timestamp >= batch.timestamp + CHALLENGE_PERIOD);
        require(!batch.finalized);

        stateRoot = batch.newStateRoot;
        batch.finalized = true;
    }
}
```

**Examples:** Optimism, Arbitrum, Base, Mantle, Blast

As of 2025, optimistic rollups dominate L2 usage:
- **Arbitrum**: ~60% of L2 TVL, largest ecosystem
- **Optimism/OP Stack**: Powers Base (Coinbase), Mantle, and others
- **Base**: Fastest-growing L2, backed by Coinbase

**Tradeoffs:**
- ✅ EVM equivalent (same code works)
- ✅ Lower gas costs than L1 (~10x cheaper pre-blobs, ~100x cheaper post-blobs)
- ❌ 7-day withdrawal period (for security)
- ❌ Relies on at least one honest challenger

### ZK-Rollups

Use zero-knowledge proofs to prove validity:

```solidity
// Simplified ZK rollup contract
contract ZKRollup {
    bytes32 public stateRoot;
    IVerifier public verifier;

    function submitBatch(
        bytes32 newStateRoot,
        bytes calldata txData,
        bytes calldata proof
    ) external {
        // Verify ZK proof
        require(
            verifier.verify(stateRoot, newStateRoot, txData, proof),
            "Invalid proof"
        );

        // Immediately update state (no challenge period!)
        stateRoot = newStateRoot;
    }
}
```

**Examples:** zkSync Era, Polygon zkEVM, Scroll, Linea, Starknet (non-EVM)

The ZK rollup landscape matured significantly in 2024-2025:
- **zkSync Era**: Production since 2023, account abstraction native
- **Polygon zkEVM**: Type-2 EVM equivalence
- **Scroll**: Type-2 EVM equivalence, decentralizing prover network
- **Linea**: ConsenSys-backed, production since 2023

**Tradeoffs:**
- ✅ Fast finality (minutes, not days)
- ✅ Strong cryptographic guarantees
- ✅ Proving costs decreasing rapidly (ASIC acceleration, recursive proofs)
- ❌ More complex infrastructure than optimistic rollups
- ❌ Some EVM edge cases may differ

## Rollup Comparison

| Aspect | Optimistic | ZK |
|--------|------------|-----|
| Finality | 7 days | Minutes |
| Proof cost | Low (fraud proof only if challenged) | High (every batch) |
| EVM compatibility | Excellent | Improving |
| Maturity | Production | Production |
| Examples | Arbitrum, Optimism | zkSync, Polygon zkEVM |

## Data Availability

Rollups need transaction data available to reconstruct state:

**On-chain data (Rollups):**
- Data posted to L1 calldata
- Most secure, but expensive
- ~16 bytes/tx after compression

**Off-chain data (Validiums):**
- Data stored off-chain (committee, DAC)
- Cheaper, but trust assumptions
- Examples: StarkEx, zkPorter

**EIP-4844 (Proto-Danksharding) — Ethereum Only:**

The Dencun upgrade (March 2024) introduced "blob-carrying transactions" that dramatically reduce rollup costs:

```
┌─────────────────────────────────────────────────────────────┐
│                    Blob Transaction                          │
│  ┌─────────────────────┐  ┌─────────────────────────────┐  │
│  │  Regular Tx Fields  │  │  Blob Data (up to 6 blobs)  │  │
│  │  (to, value, data)  │  │  ~128 KB per blob           │  │
│  └─────────────────────┘  └─────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

Key characteristics:
- **Blobs are temporary** — Pruned after ~18 days (4096 epochs)
- **Separate fee market** — `blobBaseFee` adjusts independently of gas
- **~10-100x cheaper** than calldata for L2 data posting
- **Target: 3 blobs/block** — ~0.375 MB/block data capacity

Economics:
- Blob gas has its own base fee mechanism (like EIP-1559)
- When blob demand exceeds target, `blobBaseFee` increases
- When demand is low, blobs cost nearly nothing

Impact on L2 costs:
```
Before EIP-4844:  ~$0.10-$1.00 per L2 transaction (calldata)
After EIP-4844:   ~$0.001-$0.01 per L2 transaction (blobs)
```

<Callout type="note">
**ETC and Blob Transactions**: Ethereum Classic does not implement EIP-4844 (blob transactions). As a proof-of-work chain without L2 rollup infrastructure, there's no demand for blob data availability. ETC's lower base load means congestion isn't a current concern. If L2 development occurs on ETC in the future, alternative data availability solutions could be explored.
</Callout>

## State Channels

State channels move transactions completely off-chain:

```
1. Open channel: Lock funds on-chain
2. Transact: Exchange signed messages off-chain
3. Close channel: Settle final state on-chain
```

```solidity
contract PaymentChannel {
    address public sender;
    address public recipient;
    uint256 public expiration;

    function close(uint256 amount, bytes memory signature) external {
        require(msg.sender == recipient);
        require(verifySignature(amount, signature, sender));

        // Pay recipient
        payable(recipient).transfer(amount);
        // Return remainder to sender
        selfdestruct(payable(sender));
    }
}
```

**Examples:** Lightning Network (Bitcoin), Raiden (Ethereum)

**Best for:** High-frequency transactions between known parties

## Sidechains

Separate blockchains connected via bridges:

```
┌─────────────────┐         Bridge         ┌─────────────────┐
│   Main Chain    │ ◀───────────────────▶  │    Sidechain    │
│  (Ethereum)     │   Lock ◀──▶ Mint      │  (Polygon PoS)  │
└─────────────────┘                        └─────────────────┘
```

**Examples:** Polygon PoS, Gnosis Chain

**Tradeoffs:**
- ✅ High throughput
- ✅ Independent consensus
- ❌ Different security assumptions than L1
- ❌ Bridge security is critical

## Scaling Ethereum Classic

Ethereum Classic, maintaining PoW consensus, has different scaling considerations:

<Note>
ETC has inherently lower demand than ETH, so congestion is less of an issue currently. However, the same L2 technologies can work on ETC:

- Rollup contracts can be deployed on ETC
- The challenge: L2s need liquidity and users
- Cross-chain bridges can connect ETC to L2 ecosystems
</Note>

## Building for L2

### Deploying to L2

Most L2s are EVM-equivalent:

```javascript
// hardhat.config.js
module.exports = {
  networks: {
    optimism: {
      url: "https://mainnet.optimism.io",
      chainId: 10,
    },
    arbitrum: {
      url: "https://arb1.arbitrum.io/rpc",
      chainId: 42161,
    },
    base: {
      url: "https://mainnet.base.org",
      chainId: 8453,
    },
  },
};
```

Your contracts deploy unchanged — same Solidity, same tools.

### L1 ↔ L2 Communication

Rollups have messaging systems:

```solidity
// Send message from L1 to L2 (Optimism example)
interface ICrossDomainMessenger {
    function sendMessage(
        address target,
        bytes memory message,
        uint32 gasLimit
    ) external;
}

function sendToL2(address l2Contract, bytes memory data) external {
    messenger.sendMessage(l2Contract, data, 1000000);
}
```

### Bridging Assets

```solidity
// Simplified bridge deposit
function depositToL2(address token, uint256 amount) external {
    // Lock tokens on L1
    IERC20(token).transferFrom(msg.sender, address(this), amount);

    // Emit event for relayer
    emit Deposit(msg.sender, token, amount);

    // L2 bridge mints equivalent tokens
}
```

### Withdrawal Delays

Optimistic rollups have 7-day withdrawals:

```solidity
struct Withdrawal {
    address user;
    uint256 amount;
    uint256 timestamp;
}

function initiateWithdrawal(uint256 amount) external {
    withdrawals[msg.sender] = Withdrawal(msg.sender, amount, block.timestamp);
}

function finalizeWithdrawal() external {
    Withdrawal memory w = withdrawals[msg.sender];
    require(block.timestamp >= w.timestamp + 7 days, "Too early");

    delete withdrawals[msg.sender];
    payable(msg.sender).transfer(w.amount);
}
```

**Fast bridges** (Hop, Across) provide instant liquidity by fronting funds.

## The Future: A Multi-Chain World

The ecosystem is evolving toward:

- **Multiple rollups** — Specialized for different use cases (DeFi, gaming, social)
- **Shared sequencing** — Atomic cross-rollup transactions (Espresso, Astria)
- **Data availability layers** — Celestia (live), EigenDA (live), Avail
- **Account abstraction** — EIP-4337 (live), native AA via EIP-7702 (Pectra)
- **Restaking** — EigenLayer enabling shared security for new services
- **Based rollups** — Sequencing by L1 validators for maximum decentralization

<Callout type="info">
**Pectra Upgrade (Late 2024)**: Ethereum's Pectra fork introduced EIP-7702 for native account abstraction, allowing EOAs to temporarily act as smart contract wallets. This significantly improves L2 UX by enabling gas sponsorship, batched transactions, and programmable wallet behavior without deploying separate smart contract wallets.
</Callout>

```
                    ┌─────────────────────────┐
                    │      User Wallet        │
                    │  (Abstract chain away)  │
                    └───────────┬─────────────┘
                                │
            ┌───────────────────┼───────────────────┐
            │                   │                   │
            ▼                   ▼                   ▼
    ┌───────────────┐   ┌───────────────┐   ┌───────────────┐
    │   Rollup A    │   │   Rollup B    │   │   Rollup C    │
    │   (DeFi)      │   │   (Gaming)    │   │   (NFTs)      │
    └───────┬───────┘   └───────┬───────┘   └───────┬───────┘
            │                   │                   │
            └───────────────────┼───────────────────┘
                                │
                                ▼
                    ┌─────────────────────────┐
                    │     Ethereum (L1)       │
                    │  Security & Settlement  │
                    └─────────────────────────┘
```

## Conclusions

Scaling blockchain technology involves tradeoffs:

- **Rollups** are the dominant L2 solution, offering 10-100x throughput improvements
- **Optimistic rollups** are EVM-equivalent but have 7-day withdrawal delays
- **ZK rollups** offer faster finality but are more complex
- **Data availability** is a key bottleneck being addressed by EIP-4844

For developers:
- L2s are EVM-compatible — same tools, same code
- Consider deployment chain based on use case
- Handle cross-chain communication carefully
- Account for withdrawal delays in UX

The same smart contract code runs on L1, L2, and ETC — the EVM is the constant.
