---
title: Consensus & Finality
description: Proof of Work, Proof of Stake, and how blockchains agree on state
chapter: 7
---

# Consensus Mechanisms

Consensus is how a decentralized network agrees on the state of the blockchain. It's the mechanism that allows thousands of nodes around the world to maintain the same transaction history without a central authority.

This chapter explores the two primary consensus mechanisms in the EVM ecosystem: **Proof of Work (PoW)**, used by Ethereum Classic, and **Proof of Stake (PoS)**, used by Ethereum since The Merge.

## The Byzantine Generals Problem

Consensus mechanisms solve the Byzantine Generals Problem: how can distributed parties reach agreement when some parties may be faulty or malicious?

In blockchain terms:
- How do we know which transactions are valid?
- How do we decide which block comes next?
- How do we prevent double-spending?

The solution involves making it economically or computationally expensive to misbehave, while rewarding honest behavior.

## Proof of Work (PoW)

Proof of Work was the original consensus mechanism for Bitcoin and Ethereum. It remains the consensus mechanism for Ethereum Classic.

### How PoW Works

Miners compete to find a nonce that, when combined with block data and hashed, produces a result below a target threshold:

```
hash(block_header, nonce) < target
```

The target adjusts to maintain a consistent block time (~13 seconds for ETC).

### The Mining Process

1. **Gather transactions** — Select transactions from the mempool
2. **Build block header** — Include previous hash, merkle root, timestamp
3. **Find valid nonce** — Brute-force search for valid hash
4. **Broadcast block** — Share the solution with the network
5. **Receive reward** — Earn block reward + transaction fees

```solidity
// Simplified concept
function isValidBlock(Block memory block) public pure returns (bool) {
    bytes32 hash = keccak256(abi.encodePacked(
        block.previousHash,
        block.merkleRoot,
        block.timestamp,
        block.nonce
    ));
    return uint256(hash) < block.difficulty;
}
```

### ETCHash Algorithm

Ethereum Classic uses ETCHash (a variant of Ethash) with these properties:

- **Memory-hard** — Requires significant RAM (GPU friendly, ASIC resistant)
- **DAG-based** — Uses a Directed Acyclic Graph that grows over time
- **Adjusting difficulty** — Maintains ~13 second block times

<Note>
The DAG is the large dataset that miners must load into memory. It grows by 8MB per 30,000 blocks (about 5.2 days). The current DAG size can be found at https://minerstat.com/dag-size-calculator.
</Note>

### Chain Selection: Longest Chain Rule

When nodes receive multiple valid chains, they follow the one with the most accumulated work (highest total difficulty):

```
Chain A: Block 1 ─── Block 2 ─── Block 3
                                    ↑
Chain B: Block 1 ─── Block 2 ───────┘

If Chain A has more total difficulty, all honest nodes will follow Chain A.
```

### PoW Security

**51% Attack** — An attacker with majority hashpower can:
- Reorder transactions
- Double-spend
- Censor transactions

The defense is that acquiring 51% hashpower is extremely expensive.

**Economics:**
- Attacking ETC would cost millions in hardware and electricity
- Attackers lose money if the attack reduces coin value
- Honest mining is generally more profitable

### Block Rewards

Ethereum Classic's block reward schedule:

| Era | Block Range | Reward |
|-----|-------------|--------|
| Era 1 | 0 - 5,000,000 | 5 ETC |
| Era 2 | 5,000,001 - 10,000,000 | 4 ETC |
| Era 3 | 10,000,001 - 15,000,000 | 3.2 ETC |
| Era 4 | 15,000,001 - 20,000,000 | 2.56 ETC |
| Era 5+ | 20,000,001+ | Continues decreasing by 20% |

This creates a fixed monetary policy similar to Bitcoin's halving schedule.

## ETC Olympia Upgrade

The Olympia upgrade represents a significant evolution for Ethereum Classic, bringing modern transaction semantics while solving the challenge of decentralized protocol funding.

### The Olympia ECIP Family

Olympia is implemented through a coordinated family of Ethereum Classic Improvement Proposals:

| ECIP | Title | Layer |
|------|-------|-------|
| **ECIP-1111** | EIP-1559 + EIP-3198 semantics | Consensus |
| **ECIP-1112** | Treasury address and custody | Consensus |
| **ECIP-1121** | Opcode alignment (PUSH0, MCOPY, etc.) | Consensus |
| ECIP-1113-1120 | Governance frameworks | Application |

The core consensus changes are ECIP-1111, 1112, and 1121. The governance ECIPs (1113-1120) define application-layer frameworks for treasury management but don't require hard fork changes.

### ECIP-1111: EIP-1559 Transaction Semantics

ECIP-1111 brings EIP-1559-style transactions to Ethereum Classic:

- **Type 2 transactions**: `maxFeePerGas` and `maxPriorityFeePerGas` fields
- **Base fee algorithm**: Adjusts based on block fullness, targeting 50% capacity
- **EIP-3198**: Exposes `BASEFEE` opcode for contracts to read the current base fee

The transaction format and fee calculation are identical to Ethereum's implementation. Existing wallets and tooling that support EIP-1559 will work seamlessly.

### ECIP-1112: Treasury Funding Mechanism

Here's where Olympia diverges from Ethereum. Instead of burning the base fee:

```
Ethereum (post-London):
├── Base fee → BURNED
└── Priority fee → Validator

Ethereum Classic (post-Olympia):
├── Base fee → Treasury address
└── Priority fee → Miner
```

The treasury address is **consensus-recognized**—meaning nodes enforce that base fees go to this specific address. It's not a smart contract that could be exploited; it's built into the protocol rules.

#### Why Treasury Funding?

Decentralized networks face a fundamental challenge: how do you fund ongoing development without:
1. A central foundation with pre-mined funds (centralization risk)
2. Inflationary block rewards (dilutes existing holders)
3. Relying on altruism (unsustainable)

Olympia's solution: **redirect existing fee revenue**. Users already pay transaction fees. Rather than burning this value (which benefits all holders abstractly through scarcity) or giving it entirely to miners (who provide security but not development), Olympia allocates the base fee portion to protocol development.

This creates sustainable funding without:
- New token issuance
- Increased fees for users
- Central control of funds

#### Treasury Governance

ECIP-1113 through ECIP-1120 establish governance frameworks for treasury management. These operate at the application layer, using multisig contracts and community voting to direct funds. The consensus layer only enforces that fees go to the treasury address—how those funds are spent is determined by off-chain governance processes.

### ECIP-1121: Opcode Alignment

ECIP-1121 brings ETC's opcode set in line with Ethereum's recent additions:

| Opcode | Hex | Description | EIP |
|--------|-----|-------------|-----|
| PUSH0 | 0x5F | Push zero to stack | EIP-3855 |
| MCOPY | 0x5E | Memory copy | EIP-5656 |
| TLOAD | 0x5C | Transient storage load | EIP-1153 |
| TSTORE | 0x5D | Transient storage store | EIP-1153 |
| BLOBHASH | 0x49 | Get blob hash | EIP-4844* |
| BLOBBASEFEE | 0x4A | Get blob base fee | EIP-7516* |

*Note: BLOBHASH and BLOBBASEFEE are included for bytecode compatibility but return zero on ETC since blob transactions (EIP-4844) are not implemented on proof-of-work chains.

This opcode alignment ensures that smart contracts compiled for recent Ethereum versions will execute correctly on ETC. Without these opcodes, contracts using Solidity 0.8.20+ or newer tooling would fail to deploy.

### Impact on Miners and Users

**For users**: Transaction fee estimation becomes more predictable. The base fee algorithm smooths out fee spikes. Users get refunds when their `maxFeePerGas` exceeds the actual cost.

**For miners**: Priority fees remain the incentive for transaction inclusion. Miners can still order transactions by priority fee and extract MEV. Block rewards (from the fixed emission schedule) continue unchanged.

**For developers**: Modern tooling works out of the box. Contracts can read `BASEFEE`. New opcodes enable gas optimizations (PUSH0 saves gas vs PUSH1 0x00).

### Philosophical Implications

Olympia represents ETC's approach to evolution: adopt proven improvements (EIP-1559's UX benefits, modern opcodes) while charting a distinct path on economic policy (treasury vs burn).

This is consistent with ETC's values:
- **Immutability**: No irregular state changes; the chain history remains unaltered
- **Sound money**: Fixed emission schedule unchanged; no new issuance
- **Decentralization**: Treasury enables funding without central control

## Proof of Stake (PoS)

Proof of Stake replaces computational work with economic stake. Ethereum transitioned to PoS in September 2022 ("The Merge").

### How PoS Works

Validators stake 32 ETH as collateral. The protocol randomly selects validators to propose and attest to blocks:

1. **Proposer** — One validator is chosen to propose the next block
2. **Attesters** — Other validators vote on the block's validity
3. **Finality** — After enough attestations, blocks become finalized
4. **Rewards** — Honest validators earn rewards
5. **Slashing** — Dishonest validators lose stake

### Validator Lifecycle

```
       ┌─────────────┐
       │   Deposit   │ (32 ETH)
       │   32 ETH    │
       └──────┬──────┘
              ▼
       ┌─────────────┐
       │   Pending   │ (wait for activation queue)
       │   Queue     │
       └──────┬──────┘
              ▼
       ┌─────────────┐
       │   Active    │ (proposing & attesting)
       │  Validator  │
       └──────┬──────┘
              ▼
       ┌─────────────┐
       │    Exit     │ (voluntary or slashed)
       │             │
       └──────┬──────┘
              ▼
       ┌─────────────┐
       │  Withdraw   │ (get stake back)
       │             │
       └─────────────┘
```

### Slots and Epochs

Time is divided into:
- **Slots** — 12 seconds each, one block per slot
- **Epochs** — 32 slots (6.4 minutes)

Each slot, one validator proposes a block and ~1/32 of validators attest.

### Finality

Unlike PoW (probabilistic finality), PoS provides:
- **Justified** — After 1 epoch (~6.4 min), very hard to revert
- **Finalized** — After 2 epochs (~12.8 min), economically impossible to revert

### Slashing Conditions

Validators are slashed (lose stake) for:

1. **Double voting** — Attesting to two different blocks in the same slot
2. **Surround voting** — Attesting in a way that contradicts prior attestations
3. **Proposer equivocation** — Proposing two different blocks in the same slot

Slashing burns 1/32 of stake immediately, with more burned if many validators are slashed simultaneously.

### PoS Security

**34% Attack** — An attacker with 34%+ stake can:
- Prevent finality
- Censor transactions

**51%+ Attack** — An attacker with 51%+ stake can:
- Control block production
- Reorder transactions

**Defense:**
- Slashing makes attacks expensive
- Social layer can coordinate responses
- Inactivity leak degrades inactive validators

## PoW vs PoS Comparison

| Aspect | PoW (Ethereum Classic) | PoS (Ethereum) |
|--------|------------------------|----------------|
| **Block time** | ~13 seconds | 12 seconds |
| **Finality** | Probabilistic (~10 min) | Economic (~13 min) |
| **Energy use** | High | Low (~99.95% less) |
| **Entry cost** | Mining hardware | 32 ETH stake |
| **Centralization risk** | Mining pools | Staking pools |
| **Attack cost** | Hardware + electricity | Stake at risk |
| **Philosophy** | Immutable, original Ethereum | Adaptive, evolving |

## The Fork: ETH vs ETC

In 2016, The DAO hack led to a contentious hard fork:

- **Ethereum (ETH)** — Forked to return stolen funds, later moved to PoS
- **Ethereum Classic (ETC)** — Maintained original chain, stayed on PoW

Both chains share the same EVM specification and can run the same smart contracts. The difference is in consensus, not computation.

<Note>
This philosophical difference is fundamental:
- **ETH** prioritizes adaptability and sustainability
- **ETC** prioritizes immutability and original principles

Neither is "wrong" — they represent different values in decentralized systems.
</Note>

## Smart Contract Implications

Consensus mechanisms affect smart contract development in subtle ways:

### Timestamp Manipulation

- **PoW**: Miners can manipulate timestamps by ~15 seconds
- **PoS**: Validators have less flexibility, slots are 12 seconds

### Block Producer Behavior

- **PoW**: Miners can front-run by including their own transactions
- **PoS**: Proposer-Builder Separation (PBS) mitigates some MEV

### Finality Considerations

```solidity
// How many confirmations to wait?

// On ETC (PoW): Wait for ~50 confirmations (~10 minutes)
// On ETH (PoS): Wait for finality (~13 minutes, or 32 blocks)

function isConfirmed(uint256 blockNumber) public view returns (bool) {
    // ETC: 50 confirmations
    return block.number >= blockNumber + 50;

    // ETH: Could check finality checkpoint
    // return block.number >= blockNumber + 32;
}
```

### `block.difficulty` / `block.prevrandao`

```solidity
// This behaves differently on PoW vs PoS!

function getSomeValue() public view returns (uint256) {
    // On ETC (PoW): Returns mining difficulty
    // On ETH (PoS): Returns random value from beacon chain
    return block.difficulty;
}
```

## Running a Validator / Miner

### Mining ETC (PoW)

Requirements:
- GPU with 4GB+ VRAM (for DAG)
- Mining software (ethminer, T-Rex, etc.)
- Full node or mining pool

```bash
# Start Core Geth with mining
geth --classic --mine --miner.etherbase=0xYourAddress
```

### Staking ETH (PoS)

Requirements:
- 32 ETH per validator
- Execution client (Geth, Nethermind, etc.)
- Consensus client (Lighthouse, Prysm, etc.)
- 24/7 reliable uptime

Or use staking pools (Lido, Rocket Pool) for smaller amounts.

## Conclusions

Consensus is the foundation that makes trustless blockchains possible:

- **Proof of Work** — Security through computational expense
- **Proof of Stake** — Security through economic stake at risk

Both mechanisms secure the same EVM — your smart contracts work identically on either chain. The choice between them reflects different priorities:

- PoW: Proven security model, energy-intensive, original design
- PoS: Energy-efficient, faster finality, evolving design

Understanding consensus helps you write better smart contracts by knowing:
- How block producers are selected
- What timing guarantees exist
- How finality affects your application
- What attacks are possible and how to mitigate them
